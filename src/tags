!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BUF_SIZE	cir/reader.h	17;"	d
BUF_SIZE	sat/reader.h	17;"	d
CC_MINIMIZATION	sat/SolverV.cpp	25;"	d	file:
CIRMGR_H	cir/cirMgr.h	3;"	d
CIRNET_H	cir/cirNet.h	3;"	d
CIR_GATE_H	cir/cirGate.h	4;"	d
COMMON	cir/cirMgr.h	/^    COMMON,$/;"	e	enum:VAR_GROUP
CirAndGate	cir/cirGate.h	/^CirGateType(CirAndGate);$/;"	v
CirBufGate	cir/cirGate.h	/^CirGateType(CirBufGate);$/;"	v
CirConstGate	cir/cirGate.h	/^CirGateType(CirConstGate);$/;"	v
CirErrorGate	cir/cirGate.h	/^CirGateType(CirErrorGate);$/;"	v
CirGate	cir/cirGate.h	/^	CirGate(const string& name = "", unsigned id = 0): $/;"	f	class:CirGate
CirGate	cir/cirGate.h	/^class CirGate$/;"	c
CirGateType	cir/cirGate.h	127;"	d
CirGateV	cir/cirGate.h	/^	explicit CirGateV(CirGate* g = 0, bool inv = false): _gateV(reinterpret_cast<size_t>(g)) {$/;"	f	class:CirGateV
CirGateV	cir/cirGate.h	/^class CirGateV$/;"	c
CirInvGate	cir/cirGate.h	/^CirGateType(CirInvGate);$/;"	v
CirMgr	cir/cirMgr.h	/^	explicit CirMgr(const string& name = ""): $/;"	f	class:CirMgr
CirMgr	cir/cirMgr.h	/^class CirMgr$/;"	c
CirMuxGate	cir/cirGate.h	/^CirGateType(CirMuxGate);$/;"	v
CirNandGate	cir/cirGate.h	/^CirGateType(CirNandGate);$/;"	v
CirNet	cir/cirNet.h	/^	explicit CirNet(const string& name = "", unsigned id = 0): $/;"	f	class:CirNet
CirNet	cir/cirNet.h	/^class CirNet$/;"	c
CirNorGate	cir/cirGate.h	/^CirGateType(CirNorGate);$/;"	v
CirOrGate	cir/cirGate.h	/^CirGateType(CirOrGate);$/;"	v
CirPiGate	cir/cirGate.h	/^CirGateType(CirPiGate);$/;"	v
CirPoGate	cir/cirGate.h	/^CirGateType(CirPoGate);$/;"	v
CirXnorGate	cir/cirGate.h	/^CirGateType(CirXnorGate);$/;"	v
CirXorGate	cir/cirGate.h	/^CirGateType(CirXorGate);$/;"	v
Clause	sat/SolverTypesV.h	/^    Clause(bool learnt, const vec<Lit>& ps, ClauseId id_ = ClauseId_NULL) {$/;"	f	class:Clause
Clause	sat/SolverTypesV.h	/^class Clause {$/;"	c
ClauseId	sat/SolverTypesV.h	/^typedef int ClauseId;     \/\/ (might have to use uint64 one day...)$/;"	t
ClauseId_NULL	sat/SolverTypesV.h	/^const   int ClauseId_NULL = INT_MIN;$/;"	v
Clause_new	sat/SolverTypesV.h	/^inline Clause* Clause_new(bool learnt, const vec<Lit>& ps, ClauseId id = ClauseId_NULL) {$/;"	f
Current_Pos	cir/reader.h	/^	unsigned int Current_Pos()	{ return overall_pos; }$/;"	f	class:Reader
Current_Pos	sat/reader.h	/^	unsigned int Current_Pos()	{ return overall_pos; }$/;"	f	class:Reader
DEFAULTS	sat/FileV.h	40;"	d
DEFAULTS	sat/FileV.h	48;"	d
Datum	sat/GlobalV.h	/^    typedef T   Datum;$/;"	t	class:vec
EDGE_BIT	cir/cirGate.h	/^        static const size_t EDGE_BIT = 2;$/;"	m	class:CirGateV
Exception_EOF	sat/FileV.h	/^class Exception_EOF {};$/;"	c
File	sat/FileV.h	/^    File(cchar* name, cchar* mode) : DEFAULTS {$/;"	f	class:File
File	sat/FileV.h	/^    File(int fd, FileMode mode, bool own_fd = true) : DEFAULTS  {$/;"	f	class:File
File	sat/FileV.h	/^    File(void) : DEFAULTS {}$/;"	f	class:File
File	sat/FileV.h	/^class File {$/;"	c
FileMode	sat/FileV.h	/^enum FileMode { READ, WRITE };$/;"	g
File_BufSize	sat/FileV.h	22;"	d
File_h	sat/FileV.h	2;"	d
GClause	sat/SolverTypesV.h	/^    GClause(void* d) : data(d) {}$/;"	f	class:GClause
GClause	sat/SolverTypesV.h	/^class GClause {$/;"	c
GClause_NULL	sat/SolverTypesV.h	143;"	d
GClause_new	sat/SolverTypesV.h	/^inline GClause GClause_new(Clause* c) { assert(((uintp)c & 1) == 0); return GClause((void*)c); }$/;"	f
GClause_new	sat/SolverTypesV.h	/^inline GClause GClause_new(Lit p)     { return GClause((void*)(((intp)index(p) << 1) + 1)); }$/;"	f
GateList	cir/cirGate.h	/^typedef vector<CirGate*> GateList;$/;"	t
GateType	cir/cirGate.h	/^enum GateType$/;"	g
GateVList	cir/cirGate.h	/^typedef vector<CirGateV> GateVList;$/;"	t
Gate_And	cir/cirGate.h	/^	Gate_And,$/;"	e	enum:GateType
Gate_Buf	cir/cirGate.h	/^	Gate_Buf,$/;"	e	enum:GateType
Gate_Const	cir/cirGate.h	/^	Gate_Const,$/;"	e	enum:GateType
Gate_Error	cir/cirGate.h	/^	Gate_Error,$/;"	e	enum:GateType
Gate_Inv	cir/cirGate.h	/^	Gate_Inv,$/;"	e	enum:GateType
Gate_Mux	cir/cirGate.h	/^	Gate_Mux,$/;"	e	enum:GateType
Gate_Nand	cir/cirGate.h	/^	Gate_Nand,$/;"	e	enum:GateType
Gate_Nor	cir/cirGate.h	/^	Gate_Nor,$/;"	e	enum:GateType
Gate_Or	cir/cirGate.h	/^	Gate_Or,$/;"	e	enum:GateType
Gate_Pi	cir/cirGate.h	/^	Gate_Pi,$/;"	e	enum:GateType
Gate_Po	cir/cirGate.h	/^	Gate_Po,$/;"	e	enum:GateType
Gate_UNDEF	cir/cirGate.h	/^	Gate_UNDEF$/;"	e	enum:GateType
Gate_Xnor	cir/cirGate.h	/^	Gate_Xnor,$/;"	e	enum:GateType
Gate_Xor	cir/cirGate.h	/^	Gate_Xor,$/;"	e	enum:GateType
Global_h	sat/GlobalV.h	21;"	d
Heap	sat/HeapV.h	/^    Heap(C c) : comp(c) { heap.push(-1); }$/;"	f	class:Heap
Heap	sat/HeapV.h	/^class Heap {$/;"	c
Heap_h	sat/HeapV.h	21;"	d
I64_fmt	sat/GlobalV.h	41;"	d
I64_fmt	sat/GlobalV.h	47;"	d
INV_MASK	cir/cirGate.h	/^        static const size_t INV_MASK = 0x1;$/;"	m	class:CirGateV
Key	sat/GlobalV.h	/^    typedef int Key;$/;"	t	class:vec
LOCAL_OFF	cir/cirMgr.h	/^    LOCAL_OFF,$/;"	e	enum:VAR_GROUP
LOCAL_ON	cir/cirMgr.h	/^    LOCAL_ON,$/;"	e	enum:VAR_GROUP
L_LIT	sat/SolverV.h	223;"	d
L_lit	sat/SolverV.h	224;"	d
LessThan_default	sat/SortV.h	/^struct LessThan_default {$/;"	s
Lit	sat/SolverTypesV.h	/^    Lit() : x(2*var_Undef) {}   \/\/ (lit_Undef)$/;"	f	class:Lit
Lit	sat/SolverTypesV.h	/^    explicit Lit(Var var, bool sgn = false) : x((var+var) + (int)sgn) {}$/;"	f	class:Lit
Lit	sat/SolverTypesV.h	/^class Lit {$/;"	c
MYCLK_TCK	util/myUsage.h	21;"	d
MYCLK_TCK	util/myUsage.h	22;"	d
MY_USAGE_H	util/myUsage.h	10;"	d
MyUsage	util/myUsage.h	/^   MyUsage() { reset(); }$/;"	f	class:MyUsage
MyUsage	util/myUsage.h	/^class MyUsage$/;"	c
NONE	cir/cirMgr.h	/^    NONE$/;"	e	enum:VAR_GROUP
PTR_MASK	cir/cirGate.h	/^        static const size_t PTR_MASK = (~(size_t(0)) >> EDGE_BIT) << EDGE_BIT;$/;"	m	class:CirGateV
Proof	sat/ProofV.cpp	/^Proof::Proof()$/;"	f	class:Proof
Proof	sat/ProofV.cpp	/^Proof::Proof(ProofTraverser& t)$/;"	f	class:Proof
Proof	sat/ProofV.h	/^class Proof {$/;"	c
ProofTraverser	sat/ProofV.h	/^struct ProofTraverser {$/;"	s
Proof_h	sat/ProofV.h	21;"	d
RDR_EOF	cir/reader.h	18;"	d
RDR_EOF	sat/reader.h	18;"	d
READ	sat/FileV.h	/^enum FileMode { READ, WRITE };$/;"	e	enum:FileMode
Reader	cir/reader.h	/^	Reader():fd(-1)				{};$/;"	f	class:Reader
Reader	cir/reader.h	/^class Reader{$/;"	c
Reader	sat/reader.h	/^	Reader():fd(-1)				{};$/;"	f	class:Reader
Reader	sat/reader.h	/^class Reader{$/;"	c
SAT_C	sat/sat.cpp	10;"	d	file:
SAT_H	sat/sat.h	10;"	d
STATIC_ASSERTION_FAILURE	sat/GlobalV.h	/^template <> struct STATIC_ASSERTION_FAILURE<true>{};$/;"	s
SatSolverV	sat/sat.cpp	/^SatSolverV::SatSolverV()$/;"	f	class:SatSolverV
SatSolverV	sat/sat.h	/^class SatSolverV$/;"	c
SearchParams	sat/SolverV.h	/^    SearchParams(double v = 1, double c = 1, double r = 0) : var_decay(v), clause_decay(c), random_var_freq(r) { }$/;"	f	struct:SearchParams
SearchParams	sat/SolverV.h	/^struct SearchParams {$/;"	s
SolverStats	sat/SolverV.h	/^    SolverStats() : starts(0), decisions(0), propagations(0), conflicts(0)$/;"	f	struct:SolverStats
SolverStats	sat/SolverV.h	/^struct SolverStats {$/;"	s
SolverTypes_h	sat/SolverTypesV.h	22;"	d
SolverV	sat/SolverV.h	/^    SolverV() : ok               (true)$/;"	f	class:SolverV
SolverV	sat/SolverV.h	/^class SolverV {$/;"	c
Solver_h	sat/SolverV.h	21;"	d
Sort_h	sat/SortV.h	21;"	d
TEMPLATE_FAIL	sat/GlobalV.h	58;"	d
TempFiles	sat/ProofV.cpp	/^class TempFiles {$/;"	c	file:
UTIL_BOOL3V_H_	util/bool3v.h	9;"	d
UTIL_MYSTRING_H_	util/myString.h	9;"	d
UTIL_PARSE_H_	util/parse.h	9;"	d
UTIL_UNATE_H_	util/unate.h	9;"	d
Unateness	util/unate.h	/^  Unateness(): val_(0) {}$/;"	f	class:Unateness
Unateness	util/unate.h	/^  Unateness(const Unateness& u) { val_ = u.val_; }$/;"	f	class:Unateness
Unateness	util/unate.h	/^  explicit Unateness(unsigned u): val_(u) {}$/;"	f	class:Unateness
Unateness	util/unate.h	/^class Unateness{$/;"	c
VAR_GROUP	cir/cirMgr.h	/^enum VAR_GROUP$/;"	g
Var	sat/SolverTypesV.h	/^typedef int Var;$/;"	t
VarMap	cir/cirMgr.h	/^typedef map<Var, CirGate*> VarMap;$/;"	t
VarOrder	sat/VarOrderV.h	/^    VarOrder(const vec<char>& ass, const vec<double>& act) :$/;"	f	class:VarOrder
VarOrder	sat/VarOrderV.h	/^class VarOrder {$/;"	c
VarOrder_h	sat/VarOrderV.h	21;"	d
VarOrder_lt	sat/VarOrderV.h	/^    VarOrder_lt(const vec<double>&  act) : activity(act) { }$/;"	f	struct:VarOrder_lt
VarOrder_lt	sat/VarOrderV.h	/^struct VarOrder_lt {$/;"	s
WRITE	sat/FileV.h	/^enum FileMode { READ, WRITE };$/;"	e	enum:FileMode
_F	cir/cirMgr.h	/^	CirNet*								_F;$/;"	m	class:CirMgr
_G	cir/cirMgr.h	/^	CirNet*								_G;$/;"	m	class:CirMgr
_READER_H_	cir/reader.h	10;"	d
_READER_H_	sat/reader.h	10;"	d
__SGI_STL_INTERNAL_RELOPS	sat/GlobalV.h	276;"	d
_aborted	sat/SolverV.h	/^   bool     _aborted;$/;"	m	class:SolverV
_assump	sat/sat.h	/^      vec<Lit>            _assump;    \/\/ Assumption List for assumption solve$/;"	m	class:SatSolverV
_blockingClauses	cir/cirMgr.h	/^	std::vector<std::vector<bool>>		_blockingClauses;$/;"	m	class:CirMgr
_candNameList	cir/cirMgr.h	/^	vector<string>						_candNameList;$/;"	m	class:CirMgr
_conflictNum	sat/SolverV.h	/^   int      _conflictNum;$/;"	m	class:SolverV
_const0	cir/cirNet.h	/^	CirGate*							_const0;$/;"	m	class:CirNet
_const1	cir/cirNet.h	/^	CirGate*							_const1;$/;"	m	class:CirNet
_costSolver	cir/cirMgr.h	/^	SatSolverV*							_costSolver;$/;"	m	class:CirMgr
_costVar	cir/cirGate.h	/^	Var						_costVar;$/;"	m	class:CirGate
_costVar2Gate	cir/cirMgr.h	/^	unordered_map<Var, CirGate*>	_costVar2Gate;$/;"	m	class:CirMgr
_curVar	sat/sat.h	/^      Var                 _curVar;    \/\/ Variable currently$/;"	m	class:SatSolverV
_currentMem	util/myUsage.h	/^   double     _currentMem;$/;"	m	class:MyUsage
_currentTick	util/myUsage.h	/^   double     _currentTick;$/;"	m	class:MyUsage
_dupF	cir/cirMgr.h	/^	CirNet*								_dupF;$/;"	m	class:CirMgr
_dupG	cir/cirMgr.h	/^	CirNet*								_dupG;$/;"	m	class:CirMgr
_errorList	cir/cirNet.h	/^	GateList							_errorList;$/;"	m	class:CirNet
_gateList	cir/cirNet.h	/^	GateList							_gateList;			$/;"	m	class:CirNet
_gateV	cir/cirGate.h	/^	size_t _gateV;$/;"	m	class:CirGateV
_globalRef	cir/cirGate.cpp	/^unsigned CirGate::_globalRef = 0;$/;"	m	class:CirGate	file:
_globalRef	cir/cirGate.h	/^	static unsigned 		_globalRef;$/;"	m	class:CirGate
_id	cir/cirGate.h	/^	unsigned				_id;$/;"	m	class:CirGate
_id	cir/cirNet.h	/^	unsigned 							_id;$/;"	m	class:CirNet
_in	cir/cirGate.h	/^	GateVList				_in;$/;"	m	class:CirGate
_initMem	util/myUsage.h	/^   double     _initMem;$/;"	m	class:MyUsage
_isClauseOn	cir/cirMgr.h	/^	vector<bool>						_isClauseOn;$/;"	m	class:CirMgr
_isClauseOnDup	cir/cirMgr.h	/^	vector<bool>						_isClauseOnDup;$/;"	m	class:CirMgr
_muxAssignment	cir/cirMgr.h	/^	vector<bool>						_muxAssignment;$/;"	m	class:CirMgr
_name	cir/cirGate.h	/^	string					_name;$/;"	m	class:CirGate
_name	cir/cirMgr.h	/^	string 								_name;$/;"	m	class:CirMgr
_name	cir/cirNet.h	/^	string								_name;$/;"	m	class:CirNet
_name2GateMap	cir/cirNet.h	/^	name2GateMap					_name2GateMap;	$/;"	m	class:CirNet
_out	cir/cirGate.h	/^	GateVList				_out;$/;"	m	class:CirGate
_out	cir/cirMgr.h	/^        CirNet*                                                         _out;$/;"	m	class:CirMgr
_patch	cir/cirMgr.h	/^	CirNet*								_patch;$/;"	m	class:CirMgr
_periodUsedTime	util/myUsage.h	/^   double     _periodUsedTime;$/;"	m	class:MyUsage
_piList	cir/cirNet.h	/^	GateList							_piList, _poList;$/;"	m	class:CirNet
_poList	cir/cirNet.h	/^	GateList							_piList, _poList;$/;"	m	class:CirNet
_ref	cir/cirGate.h	/^	mutable unsigned		_ref;$/;"	m	class:CirGate
_s	cir/cirMgr.h	/^	SatSolverV*							_s;$/;"	m	class:CirMgr
_solver	sat/sat.h	/^      SolverV            *_solver;    \/\/ Pointer to a Minisat solver$/;"	m	class:SatSolverV
_sortedCandGate	cir/cirMgr.h	/^	vector<CirGate*>					_sortedCandGate;$/;"	m	class:CirMgr
_topoList	cir/cirNet.h	/^	mutable GateList					_topoList;$/;"	m	class:CirNet
_totalUsedTime	util/myUsage.h	/^   double     _totalUsedTime;$/;"	m	class:MyUsage
_var	cir/cirGate.h	/^	Var						_var;$/;"	m	class:CirGate
_var2Gate	cir/cirMgr.h	/^        VarMap                                                  _var2Gate;$/;"	m	class:CirMgr
_varGroup	cir/cirMgr.h	/^        vector<VAR_GROUP>                                       _varGroup;$/;"	m	class:CirMgr
_varsDup	cir/cirMgr.h	/^	std::vector<Var>					_varsDup;$/;"	m	class:CirMgr
_weight	cir/cirGate.h	/^    unsigned				_weight;$/;"	m	class:CirGate
activity	sat/SolverTypesV.h	/^    float&    activity    ()      const { return *((float*)&data[size()]); }$/;"	f	class:Clause
activity	sat/SolverV.h	/^    vec<double>         activity;         \/\/ A heuristic measurement of the activity of a variable.$/;"	m	class:SolverV
activity	sat/VarOrderV.h	/^    const vec<double>&  activity;    \/\/ var->act. Pointer to external activity table.$/;"	m	class:VarOrder
activity	sat/VarOrderV.h	/^    const vec<double>&  activity;$/;"	m	struct:VarOrder_lt
addAllBlockings	cir/cirCost.cpp	/^CirMgr::addAllBlockings()$/;"	f	class:CirMgr
addAndCNF	sat/sat.cpp	/^void SatSolverV::addAndCNF(Var out, Var in0, bool inv0, Var in1, bool inv1)$/;"	f	class:SatSolverV
addBinary	sat/SolverV.h	/^    void    addBinary (Lit p, Lit q)        { addBinary_tmp [0] = p; addBinary_tmp [1] = q; addClause(addBinary_tmp); }$/;"	f	class:SolverV
addBinary	sat/sat.h	/^  		void addBinary(Lit lit0, Lit lit1) { _solver->addBinary(lit0, lit1); }$/;"	f	class:SatSolverV
addBinary_tmp	sat/SolverV.h	/^    vec<Lit>            addBinary_tmp;$/;"	m	class:SolverV
addBlockingAssignment	cir/cirCost.cpp	/^CirMgr::addBlockingAssignment(const std::vector<bool>& assign)$/;"	f	class:CirMgr
addClause	sat/SolverV.h	/^    void    addClause (const vec<Lit>& ps )  { if (okay()) newClause(ps); }  \/\/ (used to be a difference between internal and external method...)$/;"	f	class:SolverV
addClause	sat/sat.h	/^  		void addClause(const vec<Lit>& clause) { _solver->addClause(clause); }$/;"	f	class:SatSolverV
addCostConstraint	cir/cirCost.cpp	/^CirMgr::addCostConstraint(unsigned cost)$/;"	f	class:CirMgr
addEqCNF	sat/sat.cpp	/^void SatSolverV::addEqCNF(Var var0, Var var1, bool inv)$/;"	f	class:SatSolverV
addErrorConstraint	cir/cirSat.cpp	/^CirMgr::addErrorConstraint(CirNet* n, bool val)$/;"	f	class:CirMgr
addMuxCNF	sat/sat.cpp	/^void SatSolverV::addMuxCNF(Var out, Var in0, bool inv0, Var in1, bool inv1, Var sel, bool invSel)$/;"	f	class:SatSolverV
addNeg	util/unate.h	/^  void addNeg() { val_ |= 2; }$/;"	f	class:Unateness
addOrCNF	sat/sat.cpp	/^void SatSolverV::addOrCNF(Var out, Var in0, bool inv0, Var in1, bool inv1)$/;"	f	class:SatSolverV
addPos	util/unate.h	/^  void addPos() { val_ |= 1; }$/;"	f	class:Unateness
addRoot	sat/ProofV.cpp	/^ClauseId Proof::addRoot(vec<Lit>& cl)$/;"	f	class:Proof
addTernary	sat/SolverV.h	/^    void    addTernary(Lit p, Lit q, Lit r) { addTernary_tmp[0] = p; addTernary_tmp[1] = q; addTernary_tmp[2] = r; addClause(addTernary_tmp); }$/;"	f	class:SolverV
addTernary	sat/sat.h	/^  		void addTernary(Lit lit0, Lit lit1, Lit lit2) { _solver->addTernary(lit0, lit1, lit2); }$/;"	f	class:SatSolverV
addTernary_tmp	sat/SolverV.h	/^    vec<Lit>            addTernary_tmp;$/;"	m	class:SolverV
addToSolver	cir/cirGate.cpp	/^CirAndGate::addToSolver(SatSolverV* s) const$/;"	f	class:CirAndGate
addToSolver	cir/cirGate.cpp	/^CirBufGate::addToSolver(SatSolverV* s) const$/;"	f	class:CirBufGate
addToSolver	cir/cirGate.cpp	/^CirConstGate::addToSolver(SatSolverV* s) const$/;"	f	class:CirConstGate
addToSolver	cir/cirGate.cpp	/^CirErrorGate::addToSolver(SatSolverV* s) const$/;"	f	class:CirErrorGate
addToSolver	cir/cirGate.cpp	/^CirInvGate::addToSolver(SatSolverV* s) const$/;"	f	class:CirInvGate
addToSolver	cir/cirGate.cpp	/^CirMuxGate::addToSolver(SatSolverV* s) const$/;"	f	class:CirMuxGate
addToSolver	cir/cirGate.cpp	/^CirNandGate::addToSolver(SatSolverV* s) const$/;"	f	class:CirNandGate
addToSolver	cir/cirGate.cpp	/^CirNorGate::addToSolver(SatSolverV* s) const$/;"	f	class:CirNorGate
addToSolver	cir/cirGate.cpp	/^CirOrGate::addToSolver(SatSolverV* s) const$/;"	f	class:CirOrGate
addToSolver	cir/cirGate.cpp	/^CirPiGate::addToSolver(SatSolverV* s) const$/;"	f	class:CirPiGate
addToSolver	cir/cirGate.cpp	/^CirPoGate::addToSolver(SatSolverV* s) const$/;"	f	class:CirPoGate
addToSolver	cir/cirGate.cpp	/^CirXnorGate::addToSolver(SatSolverV* s) const$/;"	f	class:CirXnorGate
addToSolver	cir/cirGate.cpp	/^CirXorGate::addToSolver(SatSolverV* s) const$/;"	f	class:CirXorGate
addToSolver	cir/cirMgr.h	/^	void addToSolver(CirNet* n) const { n -> addToSolver(_s); }$/;"	f	class:CirMgr
addToSolver	cir/cirSat.cpp	/^CirNet::addToSolver(SatSolverV* s) const$/;"	f	class:CirNet
addUnit	sat/SolverV.h	/^    void    addUnit   (Lit p)               { addUnit_tmp   [0] = p; addClause(addUnit_tmp); }$/;"	f	class:SolverV
addUnit	sat/sat.h	/^  		void addUnit(Lit lit0) { _solver->addUnit(lit0); }$/;"	f	class:SatSolverV
addUnitCNF	sat/sat.cpp	/^void SatSolverV::addUnitCNF(Var var, bool val)$/;"	f	class:SatSolverV
addUnit_tmp	sat/SolverV.h	/^    vec<Lit>            addUnit_tmp;$/;"	m	class:SolverV
addWeight	cir/cirParse.cpp	/^CirMgr::addWeight(const string& fileName)$/;"	f	class:CirMgr
addXnorCNF	sat/sat.cpp	/^void SatSolverV::addXnorCNF(Var out, Var in0, bool inv0, Var in1, bool inv1)$/;"	f	class:SatSolverV
addXorCNF	sat/sat.cpp	/^void SatSolverV::addXorCNF(Var out, Var in0, bool inv0, Var in1, bool inv1)$/;"	f	class:SatSolverV
addXorConstraint	cir/cirSat.cpp	/^CirMgr::addXorConstraint(CirNet* f, CirNet* g)$/;"	f	class:CirMgr
analyze	sat/SolverV.cpp	/^void SolverV::analyze(Clause* confl, vec<Lit>& out_learnt, int& out_btlevel)$/;"	f	class:SolverV
analyzeFinal	sat/SolverV.cpp	/^void SolverV::analyzeFinal(Clause* confl, bool skip_first)$/;"	f	class:SolverV
analyze_removable	sat/SolverV.cpp	/^bool SolverV::analyze_removable(Lit p, uint min_level)$/;"	f	class:SolverV
analyze_seen	sat/SolverV.h	/^    vec<char>           analyze_seen;$/;"	m	class:SolverV
analyze_stack	sat/SolverV.h	/^    vec<Lit>            analyze_stack;$/;"	m	class:SolverV
analyze_tmpbin	sat/SolverV.h	/^    Clause*             analyze_tmpbin;$/;"	m	class:SolverV
analyze_toclear	sat/SolverV.h	/^    vec<Lit>            analyze_toclear;$/;"	m	class:SolverV
assertProperty	sat/sat.cpp	/^void SatSolverV::assertProperty(const size_t& var, const bool& invert)$/;"	f	class:SatSolverV
assigns	sat/SolverV.h	/^    vec<char>           assigns;          \/\/ The current assignments (lbool:s stored as char:s).$/;"	m	class:SolverV
assigns	sat/VarOrderV.h	/^    const vec<char>&    assigns;     \/\/ var->val. Pointer to external assignment table.$/;"	m	class:VarOrder
assume	sat/SolverV.cpp	/^bool SolverV::assume(Lit p) {$/;"	f	class:SolverV
assumeProperty	sat/sat.cpp	/^void SatSolverV::assumeProperty(const size_t& var, const bool& invert)$/;"	f	class:SatSolverV
assumeRelease	sat/sat.cpp	/^void SatSolverV::assumeRelease() { _assump.clear(); }$/;"	f	class:SatSolverV
assump_solve	sat/sat.cpp	/^const bool SatSolverV::assump_solve()$/;"	f	class:SatSolverV
beginChain	sat/ProofV.cpp	/^void Proof::beginChain(ClauseId start)$/;"	f	class:Proof
bool_3v	util/bool3v.h	/^  bool_3v()                     : value(0) {}$/;"	f	class:bool_3v
bool_3v	util/bool3v.h	/^  explicit bool_3v(bool x)      : value(x) {}$/;"	f	class:bool_3v
bool_3v	util/bool3v.h	/^  explicit bool_3v(unsigned v)  : value(v) {}$/;"	f	class:bool_3v
bool_3v	util/bool3v.h	/^class bool_3v {$/;"	c
buf	cir/reader.h	/^	unsigned char* 	buf;$/;"	m	class:Reader
buf	sat/FileV.h	/^    uchar*      buf;        \/\/ Read or write buffer.$/;"	m	class:File
buf	sat/reader.h	/^	unsigned char* 	buf;$/;"	m	class:Reader
buildItp	cir/cirSat.cpp	/^CirMgr::buildItp(const string& fileName)$/;"	f	class:CirMgr
buildTopoList	cir/cirNet.cpp	/^CirNet::buildTopoList() const$/;"	f	class:CirNet
buildTopoListRec	cir/cirNet.cpp	/^CirNet::buildTopoListRec(CirGate* g) const$/;"	f	class:CirNet
buildVarMap	cir/cirSat.cpp	/^CirMgr::buildVarMap(CirNet* ntk) {$/;"	f	class:CirMgr
cancelUntil	sat/SolverV.cpp	/^void SolverV::cancelUntil(int level) {$/;"	f	class:SolverV
cap	sat/GlobalV.h	/^    int cap;$/;"	m	class:vec
capacity	sat/GlobalV.h	/^    void     capacity (int size) { grow(size); }$/;"	f	class:vec
cchar	sat/GlobalV.h	/^typedef const char    cchar;$/;"	t
chain	sat/ProofV.h	/^    virtual void chain  (const vec<ClauseId>& cs, const vec<Var>& xs) {}$/;"	f	struct:ProofTraverser
chain_id	sat/ProofV.h	/^    vec<ClauseId>   chain_id;$/;"	m	class:Proof
chain_var	sat/ProofV.h	/^    vec<Var>        chain_var;$/;"	m	class:Proof
check	sat/SolverV.h	/^inline void check(bool expr) { assert(expr); }$/;"	f
checkMem	util/myUsage.h	/^   double checkMem() const {$/;"	f	class:MyUsage
checkPo	cir/cirProof.cpp	/^CirMgr::checkPo()$/;"	f	class:CirMgr
checkTick	util/myUsage.h	/^   double checkTick() const {$/;"	f	class:MyUsage
claBumpActivity	sat/SolverV.h	/^    void     claBumpActivity (Clause* c) { if ( (c->activity() += cla_inc) > 1e20 ) claRescaleActivity(); }$/;"	f	class:SolverV
claDecayActivity	sat/SolverV.h	/^    void     claDecayActivity  () { cla_inc *= cla_decay; }$/;"	f	class:SolverV
claRescaleActivity	sat/SolverV.cpp	/^void SolverV::claRescaleActivity()$/;"	f	class:SolverV
cla_decay	sat/SolverV.h	/^    double              cla_decay;        \/\/ INVERSE decay factor for clause activity: stores 1\/decay.$/;"	m	class:SolverV
cla_inc	sat/SolverV.h	/^    double              cla_inc;          \/\/ Amount to bump next clause with.$/;"	m	class:SolverV
clause	sat/ProofV.h	/^    vec<Lit>        clause;$/;"	m	class:Proof
clause	sat/SolverTypesV.h	/^    Clause*     clause   () const { return (Clause*)data; }$/;"	f	class:GClause
clause_decay	sat/SolverV.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
clauses	sat/SolverV.h	/^    vec<Clause*>        clauses;          \/\/ List of problem clauses.$/;"	m	class:SolverV
clauses_literals	sat/SolverV.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
clear	sat/GlobalV.h	/^void vec<T>::clear(bool dealloc) {$/;"	f	class:vec
clearFanout	cir/cirGate.h	/^	void clearFanout()									{ _out.clear(); }$/;"	f	class:CirGate
close	cir/reader.cpp	/^void Reader::close(){$/;"	f	class:Reader
close	sat/FileV.cpp	/^void File::close(void)$/;"	f	class:File
close	sat/reader.cpp	/^void Reader::close(){$/;"	f	class:Reader
comp	sat/HeapV.h	/^    C        comp;$/;"	m	class:Heap
compress	sat/ProofV.cpp	/^void Proof::compress(Proof& dst, ClauseId goal)$/;"	f	class:Proof
conflict	sat/SolverV.h	/^    vec<Lit>    conflict;           \/\/ If problem is unsatisfiable under assumptions, this vector represent the conflict clause expressed in the assumptions.$/;"	m	class:SolverV
conflict_id	sat/SolverV.h	/^    ClauseId    conflict_id;        \/\/ (In proof logging mode only.) ID for the clause 'conflict' (for proof traverseral). NOTE! The empty clause is always the last clause derived, but for conflicts under assumption, this is not necessarly true.$/;"	m	class:SolverV
conflicts	sat/SolverV.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
connect	cir/cirParse.cpp	/^CirNet::connect(const vector<string>& tokens, const GateType& t)$/;"	f	class:CirNet
connectXor	cir/cirDup.cpp	/^CirMgr::connectXor(CirNet* f, CirNet* g)$/;"	f	class:CirMgr
copyTo	sat/GlobalV.h	/^    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) new (&copy[i]) T(data[i]); }$/;"	f	class:vec
cpuTime	sat/GlobalV.h	/^static inline double cpuTime(void) {$/;"	f
createConst	cir/cirNet.cpp	/^CirNet::createConst(bool val)$/;"	f	class:CirNet
createGate	cir/cirNet.cpp	/^CirNet::createGate(const GateType& t, const string& name, unsigned id)$/;"	f	class:CirNet
createGateRec	cir/cirParse.cpp	/^CirNet::createGateRec(const vector<string>& tokens, const GateType& t, unsigned i)$/;"	f	class:CirNet
createMux	cir/cirNet.cpp	/^CirNet::createMux(CirGate* g_F, CirGate* g_dupF)$/;"	f	class:CirNet
createMux4Candidates	cir/cirMgr.cpp	/^CirMgr::createMux4Candidates()$/;"	f	class:CirMgr
createVar	cir/cirMgr.h	/^	void createVar(CirNet* n) const { n -> createVar(_s); }$/;"	f	class:CirMgr
createVar	cir/cirSat.cpp	/^CirNet::createVar(SatSolverV* s) const$/;"	f	class:CirNet
createVar4CostSolver	cir/cirCost.cpp	/^CirMgr::createVar4CostSolver(bool setMgr)$/;"	f	class:CirMgr
data	sat/GlobalV.h	/^    T*  data;$/;"	m	class:vec
data	sat/SolverTypesV.h	/^    Lit     data[1];$/;"	m	class:Clause
data	sat/SolverTypesV.h	/^    void*   data;$/;"	m	class:GClause
decisionLevel	sat/SolverV.h	/^    int      decisionLevel() const { return trail_lim.size(); }$/;"	f	class:SolverV
decisions	sat/SolverV.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
decode64	sat/FileV.h	/^static inline int64  decode64(uint64 val)           { return ((val & 1) == 0) ? (int64)(val >> 1) : ~(int64)(val >> 1); }$/;"	f
default_params	sat/SolverV.h	/^    SearchParams    default_params;     \/\/ Restart frequency etc.$/;"	m	class:SolverV
deleted	sat/ProofV.cpp	/^void Proof::deleted(ClauseId gone)$/;"	f	class:Proof
deleted	sat/ProofV.h	/^    virtual void deleted(ClauseId c) {}$/;"	f	struct:ProofTraverser
done	sat/ProofV.h	/^    virtual void done   () {}$/;"	f	struct:ProofTraverser
drand	sat/GlobalV.h	/^static inline double drand(double& seed) {$/;"	f
dupNet	cir/cirDup.cpp	/^CirMgr::dupNet(CirNet* n) const$/;"	f	class:CirMgr
empty	sat/HeapV.h	/^    bool empty     ()         { return heap.size() == 1; }$/;"	f	class:Heap
encode64	sat/FileV.h	/^static inline uint64 encode64(int64  val)           { return (val >= 0) ? (uint64)val << 1 : (((uint64)(~val) << 1) | 1); }$/;"	f
endChain	sat/ProofV.cpp	/^ClauseId Proof::endChain()$/;"	f	class:Proof
enqueue	sat/SolverV.cpp	/^bool SolverV::enqueue(Lit p, Clause* from)$/;"	f	class:SolverV
eof	cir/reader.cpp	/^bool Reader::eof() {$/;"	f	class:Reader
eof	sat/FileV.h	/^    bool eof(void) {$/;"	f	class:File
eof	sat/reader.cpp	/^bool Reader::eof() {$/;"	f	class:Reader
expensive_ccmin	sat/SolverV.h	/^    bool            expensive_ccmin;    \/\/ Controls conflict clause minimization. TRUE by default.$/;"	m	class:SolverV
fd	cir/reader.h	/^	int 			fd;$/;"	m	class:Reader
fd	sat/FileV.h	/^    int         fd;         \/\/ Underlying file descriptor.$/;"	m	class:File
fd	sat/reader.h	/^	int 			fd;$/;"	m	class:Reader
files	sat/ProofV.cpp	/^    vec<cchar*> files;      \/\/ For clean-up purposed on abnormal exit.$/;"	m	class:TempFiles	file:
flipInv	cir/cirGate.h	/^	void flipInv() 				{ _gateV ^= (size_t)INV_MASK; }$/;"	f	class:CirGateV
flush	sat/FileV.h	/^    void flush(void) {$/;"	f	class:File
fp	sat/ProofV.h	/^    File            fp;$/;"	m	class:Proof
fp_name	sat/ProofV.h	/^    cchar*          fp_name;$/;"	m	class:Proof
genProofModel	cir/cirProof.cpp	/^CirMgr::genProofModel(SatSolverV& solver)$/;"	f	class:CirMgr
get64	cir/reader.cpp	/^unsigned long long Reader::get64(){$/;"	f	class:Reader
get64	sat/reader.cpp	/^unsigned long long Reader::get64(){$/;"	f	class:Reader
getAssignment	sat/sat.cpp	/^const bool SatSolverV::getAssignment(const Var& v) const$/;"	f	class:SatSolverV
getChar	cir/reader.cpp	/^unsigned int Reader::getChar(){$/;"	f	class:Reader
getChar	sat/FileV.h	/^    int getChar(void) {$/;"	f	class:File
getChar	sat/reader.cpp	/^unsigned int Reader::getChar(){$/;"	f	class:Reader
getCharQ	sat/FileV.h	/^    int getCharQ(void) {            \/\/ Quick version with minimal overhead -- don't call this in the wrong mode!$/;"	f	class:File
getConst	cir/cirNet.h	/^    CirGate* getConst(bool val) 					{ if(val) return _const1; else return _const0; }$/;"	f	class:CirNet
getCostVar	cir/cirGate.h	/^	Var getCostVar()					{ return _costVar; }$/;"	f	class:CirGate
getDataValue	sat/sat.cpp	/^const bool SatSolverV::getDataValue(const size_t& var) const $/;"	f	class:SatSolverV
getError	cir/cirNet.h	/^	CirGate* getError(unsigned idx)					{ return _errorList[idx]; }$/;"	f	class:CirNet
getErrorNum	cir/cirNet.h	/^	unsigned getErrorNum() const					{ return _errorList.size(); }$/;"	f	class:CirNet
getF	cir/cirMgr.h	/^	CirNet* getF() 						{ return _F; }$/;"	f	class:CirMgr
getFanin	cir/cirGate.h	/^	CirGate* getFanin(unsigned idx) const			{ assert(idx < _in.size()); return _in[idx].getGate(); }$/;"	f	class:CirGate
getFaninId	cir/cirGate.h	/^	unsigned getFaninId(unsigned idx) const		{ assert(idx < _in.size()); return _in[idx].getGate() -> _id; }$/;"	f	class:CirGate
getFaninSize	cir/cirGate.h	/^	unsigned getFaninSize() const						{ return _in.size(); }$/;"	f	class:CirGate
getFaninVar	cir/cirGate.h	/^	Var getFaninVar(unsigned idx) const				{ assert(idx < _in.size()); return _in[idx].getGate() -> _var; }$/;"	f	class:CirGate
getFanout	cir/cirGate.h	/^	CirGate* getFanout(unsigned idx) const			{ assert(idx < _out.size()); return _out[idx].getGate(); }$/;"	f	class:CirGate
getFanoutSize	cir/cirGate.h	/^	unsigned getFanoutSize() const					{ return _out.size(); }$/;"	f	class:CirGate
getG	cir/cirMgr.h	/^	CirNet* getG() 						{ return _G; }$/;"	f	class:CirMgr
getGate	cir/cirGate.h	/^	CirGate* getGate() const 	{ return (CirGate*)(_gateV & PTR_MASK); }$/;"	f	class:CirGateV
getGate	cir/cirNet.h	/^    CirGate* getGate(unsigned id) 					{ return _gateList[id]; }$/;"	f	class:CirNet
getGateByName	cir/cirNet.h	/^	CirGate* getGateByName(const string& n) 		{ return _name2GateMap[n]; }$/;"	f	class:CirNet
getGateNum	cir/cirNet.h	/^    unsigned getGateNum() const						{ return _gateList.size(); }$/;"	f	class:CirNet
getId	cir/cirGate.h	/^	unsigned getId() 					{ return _id; }$/;"	f	class:CirGate
getInt	sat/FileV.h	/^static inline uint64 getInt  (File& in)             { return decode64(getUInt(in)); }$/;"	f
getItp	cir/cirSat.cpp	/^CirMgr::getItp()$/;"	f	class:CirMgr
getLineSafe	util/parse.h	/^std::string getLineSafe(std::ifstream& ifs) {$/;"	f
getMode	sat/FileV.h	/^    FileMode getMode(void) {$/;"	f	class:File
getMuxAssignment	cir/cirCost.cpp	/^CirMgr::getMuxAssignment()$/;"	f	class:CirMgr
getName	cir/cirGate.h	/^	const string& getName() 		{ return _name; }$/;"	f	class:CirGate
getName	cir/cirNet.h	/^	const string& getName() const					{ return _name; }$/;"	f	class:CirNet
getNegFormula	sat/sat.h	/^      inline const size_t getNegFormula(const size_t& v) const { return (v ^ 1ul); }$/;"	f	class:SatSolverV
getNegVar	sat/sat.h	/^      inline const size_t getNegVar(const Var& v) const { return ((getPosVar(v)) | 1ul); }$/;"	f	class:SatSolverV
getNumClauses	cir/cirMgr.h	/^	unsigned getNumClauses() const 	{ return _s -> getNumClauses(); }$/;"	f	class:CirMgr
getNumClauses	sat/sat.h	/^      int getNumClauses() const { return _solver->nRootCla(); }$/;"	f	class:SatSolverV
getNumVars	cir/cirMgr.h	/^	unsigned getNumVars() const		{ return _s -> nVars(); }$/;"	f	class:CirMgr
getOriVar	sat/sat.h	/^      inline const Var getOriVar(const size_t& v) const { return (Var)(v >> 1ul); }$/;"	f	class:SatSolverV
getPath	cir/cirMgr.h	/^	CirNet* getPath() 					{ return _patch; }$/;"	f	class:CirMgr
getPi	cir/cirNet.h	/^	CirGate* getPi(unsigned idx) 					{ return _piList[idx]; }$/;"	f	class:CirNet
getPiNum	cir/cirNet.h	/^    unsigned getPiNum() const						{ return _piList.size(); }$/;"	f	class:CirNet
getPo	cir/cirNet.h	/^	CirGate* getPo(unsigned idx) 					{ return _poList[idx]; }$/;"	f	class:CirNet
getPoNum	cir/cirNet.h	/^    unsigned getPoNum() const						{ return _poList.size(); }$/;"	f	class:CirNet
getPosVar	sat/sat.h	/^      inline const size_t getPosVar(const Var& v) const { return (((size_t)v) << 1ul); }$/;"	f	class:SatSolverV
getTotalCost	cir/cirCost.cpp	/^CirMgr::getTotalCost()$/;"	f	class:CirMgr
getType	cir/cirGate.cpp	/^CirAndGate::getType() const$/;"	f	class:CirAndGate
getType	cir/cirGate.cpp	/^CirBufGate::getType() const$/;"	f	class:CirBufGate
getType	cir/cirGate.cpp	/^CirConstGate::getType() const$/;"	f	class:CirConstGate
getType	cir/cirGate.cpp	/^CirErrorGate::getType() const$/;"	f	class:CirErrorGate
getType	cir/cirGate.cpp	/^CirInvGate::getType() const$/;"	f	class:CirInvGate
getType	cir/cirGate.cpp	/^CirMuxGate::getType() const$/;"	f	class:CirMuxGate
getType	cir/cirGate.cpp	/^CirNandGate::getType() const$/;"	f	class:CirNandGate
getType	cir/cirGate.cpp	/^CirNorGate::getType() const$/;"	f	class:CirNorGate
getType	cir/cirGate.cpp	/^CirOrGate::getType() const$/;"	f	class:CirOrGate
getType	cir/cirGate.cpp	/^CirPiGate::getType() const$/;"	f	class:CirPiGate
getType	cir/cirGate.cpp	/^CirPoGate::getType() const$/;"	f	class:CirPoGate
getType	cir/cirGate.cpp	/^CirXnorGate::getType() const$/;"	f	class:CirXnorGate
getType	cir/cirGate.cpp	/^CirXorGate::getType() const$/;"	f	class:CirXorGate
getUInt	sat/FileV.cpp	/^uint64 getUInt(File& in)$/;"	f
getVal	util/unate.h	/^  unsigned getVal() const { return val_; }$/;"	f	class:Unateness
getVar	cir/cirGate.h	/^	Var getVar()						{ return _var; }$/;"	f	class:CirGate
getWeight	cir/cirGate.h	/^	unsigned getWeight()				{ return _weight; }$/;"	f	class:CirGate
getmin	sat/HeapV.h	/^    int  getmin() {$/;"	f	class:Heap
grow	sat/GlobalV.h	/^void vec<T>::grow(int min_cap) {$/;"	f	class:vec
growTo	sat/GlobalV.h	/^void vec<T>::growTo(int size) {$/;"	f	class:vec
growTo	sat/GlobalV.h	/^void vec<T>::growTo(int size, const T& pad) {$/;"	f	class:vec
hash	sat/SolverTypesV.h	/^    inline uint hash() const { return (uint)x; }$/;"	f	class:Lit
heap	sat/HeapV.h	/^    vec<int> heap;     \/\/ heap of ints$/;"	m	class:Heap
heap	sat/VarOrderV.h	/^    Heap<VarOrder_lt>   heap;$/;"	m	class:VarOrder
heapProperty	sat/HeapV.h	/^    bool heapProperty() {$/;"	f	class:Heap
heapProperty	sat/HeapV.h	/^    bool heapProperty(int i) {$/;"	f	class:Heap
id	sat/SolverTypesV.h	/^    ClauseId& id          ()      const { return *((ClauseId*)&data[size() + (int)learnt()]); }$/;"	f	class:Clause
id	sat/SolverTypesV.h	/^inline Lit  id    (Lit p, bool sgn) { Lit q; q.x = p.x ^ (int)sgn; return q; }$/;"	f
id_counter	sat/ProofV.h	/^    ClauseId        id_counter;$/;"	m	class:Proof
inHeap	sat/HeapV.h	/^    bool inHeap    (int n)    { assert(ok(n)); return indices[n] != 0; }$/;"	f	class:Heap
incRef	cir/cirGate.h	/^	static void incRef() 	        { ++_globalRef; }$/;"	f	class:CirGate
increase	sat/HeapV.h	/^    void increase  (int n)    { assert(ok(n)); assert(inHeap(n)); percolateUp(indices[n]); }$/;"	f	class:Heap
index	sat/SolverTypesV.h	/^inline int  index (Lit p) { return p.x; }                \/\/ A "toInt" method that guarantees small, positive integers suitable for array indexing.$/;"	f
indices	sat/HeapV.h	/^    vec<int> indices;  \/\/ int -> index in heap$/;"	m	class:Heap
init	cir/cirNet.cpp	/^CirNet::init()$/;"	f	class:CirNet
insert	sat/HeapV.h	/^    void insert(int n) {$/;"	f	class:Heap
int64	sat/GlobalV.h	/^typedef INT64              int64;$/;"	t
int64	sat/GlobalV.h	/^typedef long long          int64;$/;"	t
intp	sat/GlobalV.h	/^typedef INT_PTR            intp;$/;"	t
intp	sat/GlobalV.h	/^typedef __PTRDIFF_TYPE__   intp;$/;"	t
irand	sat/GlobalV.h	/^static inline int irand(double& seed, int size) {$/;"	f
isBinate	util/unate.h	/^  bool isBinate() const { return val_ == 3; }$/;"	f	class:Unateness
isFaninInv	cir/cirGate.h	/^	bool isFaninInv(unsigned idx) const				{ assert(idx < _in.size()); return _in[idx].isInv(); }$/;"	f	class:CirGate
isInv	cir/cirGate.h	/^	bool isInv() const 			{ return _gateV & (size_t)INV_MASK; }$/;"	f	class:CirGateV
isLit	sat/SolverTypesV.h	/^    bool        isLit    () const { return ((uintp)data & 1) == 1; }$/;"	f	class:GClause
isNeg	util/unate.h	/^  bool isNeg()    const { return val_ == 2; }$/;"	f	class:Unateness
isNegFormula	sat/sat.h	/^      inline const bool isNegFormula(const size_t& v) const { return (v & 1ul); }$/;"	f	class:SatSolverV
isNull	util/unate.h	/^  bool isNull()   const { return val_ == 0; }$/;"	f	class:Unateness
isPos	util/unate.h	/^  bool isPos()    const { return val_ == 1; }$/;"	f	class:Unateness
isRef	cir/cirGate.h	/^	bool isRef() 					{ return _ref == _globalRef; }$/;"	f	class:CirGate
isUnate	util/unate.h	/^  bool isUnate()  const { return isPos() || isNeg(); }$/;"	f	class:Unateness
l_False	sat/GlobalV.h	/^const lbool l_False = toLbool(-1);$/;"	v
l_True	sat/GlobalV.h	/^const lbool l_True  = toLbool( 1);$/;"	v
l_Undef	sat/GlobalV.h	/^const lbool l_Undef = toLbool( 0);$/;"	v
last	sat/GlobalV.h	/^    T&       last  (void)              { return data[sz-1]; }$/;"	f	class:vec
last	sat/GlobalV.h	/^    const T& last  (void) const        { return data[sz-1]; }$/;"	f	class:vec
last	sat/ProofV.h	/^    ClauseId last      () { assert(id_counter != ClauseId_NULL); return id_counter - 1; }$/;"	f	class:Proof
lastToFirst_lt	sat/SolverV.cpp	/^    lastToFirst_lt(const vec<int>& t) : trail_pos(t) {}$/;"	f	class:lastToFirst_lt
lastToFirst_lt	sat/SolverV.cpp	/^class lastToFirst_lt {  \/\/ Helper class to 'analyze' -- order literals from last to first occurance in 'trail[]'.$/;"	c	file:
lbool	sat/GlobalV.h	/^    explicit lbool(int v) : value(v) { }$/;"	f	class:lbool
lbool	sat/GlobalV.h	/^    lbool()       : value(0) { }$/;"	f	class:lbool
lbool	sat/GlobalV.h	/^    lbool(bool x) : value((int)x*2-1) { }$/;"	f	class:lbool
lbool	sat/GlobalV.h	/^class lbool {$/;"	c
learnt	sat/SolverTypesV.h	/^    bool      learnt      ()      const { return size_learnt & 1; }$/;"	f	class:Clause
learnts	sat/SolverV.h	/^    vec<Clause*>        learnts;          \/\/ List of learnt clauses.$/;"	m	class:SolverV
learnts_literals	sat/SolverV.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
left	sat/HeapV.h	/^static inline int left  (int i) { return i+i; }$/;"	f
level	sat/SolverV.h	/^    vec<int>            level;            \/\/ 'level[var]' is the decision level at which assignment was made.$/;"	m	class:SolverV
lit	sat/SolverTypesV.h	/^    Lit         lit      () const { return toLit(((intp)data) >> 1); }$/;"	f	class:GClause
locked	sat/SolverV.h	/^    bool     locked          (const Clause* c) const { return reason[var((*c)[0])] == c; }$/;"	f	class:SolverV
lseek64	sat/FileV.h	13;"	d
main	main/main.cpp	/^int main(int argc, char** argv) {$/;"	f
markOffsetClause	cir/cirSat.cpp	/^CirMgr::markOffsetClause(const ClauseId& cid)$/;"	f	class:CirMgr
markOnsetClause	cir/cirSat.cpp	/^CirMgr::markOnsetClause(const ClauseId& cid)$/;"	f	class:CirMgr
max	sat/GlobalV.h	/^template<class T> static inline T max(T x, T y) { return (x > y) ? x : y; }$/;"	f
max_literals	sat/SolverV.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
memReadStat	sat/GlobalV.h	/^static inline int memReadStat(int field)$/;"	f
memUsed	sat/GlobalV.h	/^static inline int64 memUsed() { return (int64)memReadStat(0) * (int64)getpagesize(); }$/;"	f
memUsed	sat/GlobalV.h	/^static inline int64 memUsed() {$/;"	f
min	sat/GlobalV.h	/^template<class T> static inline T min(T x, T y) { return (x < y) ? x : y; }$/;"	f
mkLit	sat/SolverTypesV.h	/^inline  Lit  mkLit     (Var var, bool sign) { Lit p; p.x = var + var + (int)sign; return p; }$/;"	f
mode	sat/FileV.h	/^    FileMode    mode;       \/\/ Reading or writing.$/;"	m	class:File
model	sat/SolverV.h	/^    vec<lbool>  model;              \/\/ If problem is satisfiable, this vector contains the model (if any).$/;"	m	class:SolverV
moveTo	sat/GlobalV.h	/^    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }$/;"	f	class:vec
mySolve	sat/SolverV.cpp	/^bool SolverV::mySolve(const vec<Lit>& assumps, int conflictThreshold, bool& result)$/;"	f	class:SolverV
mySplit	util/myString.h	/^std::vector<std::string> mySplit(const std::string& str) {$/;"	f
myToString	util/parse.h	/^std::string myToString(unsigned n) {$/;"	f
nAssigns	sat/SolverV.h	/^    int     nAssigns() { return trail.size(); }$/;"	f	class:SolverV
nClauses	sat/SolverV.h	/^    int     nClauses() { return clauses.size(); }$/;"	f	class:SolverV
nLearnts	sat/SolverV.h	/^    int     nLearnts() { return learnts.size(); }$/;"	f	class:SolverV
nRootCla	sat/SolverV.h	/^    int     nRootCla() { return root_cla_count; } \/\/ MODIFICATION FOR SoCV$/;"	f	class:SolverV
nVars	sat/SolverV.h	/^    int     nVars     ()                    { return assigns.size(); }$/;"	f	class:SolverV
nVars	sat/sat.h	/^		int nVars() const { return _solver -> nVars(); }$/;"	f	class:SatSolverV
name2GateMap	cir/cirNet.h	/^typedef unordered_map<string, CirGate*> name2GateMap;$/;"	t
neg	sat/SolverTypesV.h	/^	inline void neg() { x ^= 0x1; }$/;"	f	class:Lit
newClause	sat/SolverV.cpp	/^void SolverV::newClause(const vec<Lit>& ps_, bool learnt, ClauseId id )$/;"	f	class:SolverV
newVar	sat/SolverV.cpp	/^Var SolverV::newVar() {$/;"	f	class:SolverV
newVar	sat/VarOrderV.h	/^void VarOrder::newVar(void)$/;"	f	class:VarOrder
newVar	sat/sat.cpp	/^Var SatSolverV::newVar() {$/;"	f	class:SatSolverV
null	cir/reader.h	/^	bool null()					{ return fd == -1; }$/;"	f	class:Reader
null	sat/FileV.h	/^    bool null(void) {               \/\/ TRUE if no file is opened.$/;"	f	class:File
null	sat/reader.h	/^	bool null()					{ return fd == -1; }$/;"	f	class:Reader
ok	sat/HeapV.h	/^    bool ok(int n) { return n >= 0 && n < (int)indices.size(); }$/;"	f	class:Heap
ok	sat/SolverV.h	/^    bool                ok;               \/\/ If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!$/;"	m	class:SolverV
okay	sat/SolverV.h	/^    bool    okay() { return ok; }       \/\/ FALSE means solver is in an conflicting state (must never be used again!)$/;"	f	class:SolverV
open	cir/reader.cpp	/^void Reader::open( const char* file_name ){$/;"	f	class:Reader
open	cir/reader.cpp	/^void Reader::open(int filedesc)$/;"	f	class:Reader
open	sat/FileV.cpp	/^void File::open(cchar* name, cchar* mode_)$/;"	f	class:File
open	sat/FileV.cpp	/^void File::open(int file_descr, FileMode m, bool own)$/;"	f	class:File
open	sat/ProofV.cpp	/^    char* open(File& fp)$/;"	f	class:TempFiles
open	sat/reader.cpp	/^void Reader::open( const char* file_name ){$/;"	f	class:Reader
open	sat/reader.cpp	/^void Reader::open(int filedesc)$/;"	f	class:Reader
open64	sat/FileV.h	14;"	d
operator !	util/bool3v.h	/^  bool_3v operator !() const {$/;"	f	class:bool_3v
operator !=	sat/GlobalV.h	/^    bool  operator != (const lbool& other) const { return value != other.value; }$/;"	f	class:lbool
operator !=	sat/GlobalV.h	/^template <class T> static inline bool operator != (const T& x, const T& y) { return !(x == y); }$/;"	f
operator !=	sat/SolverTypesV.h	/^    bool        operator != (GClause c) const { return data != c.data; }$/;"	f	class:GClause
operator !=	util/bool3v.h	/^  bool operator != (bool_3v b) const { return !(*this == b); }$/;"	f	class:bool_3v
operator !=	util/unate.h	/^  bool operator != (const Unateness& u) const { return val_ != u.val_; }$/;"	f	class:Unateness
operator &&	util/bool3v.h	/^  bool_3v operator && (bool_3v b) const {$/;"	f	class:bool_3v
operator ()	sat/SolverV.cpp	/^    bool operator () (Lit p, Lit q) { return trail_pos[var(p)] > trail_pos[var(q)]; }$/;"	f	class:lastToFirst_lt
operator ()	sat/SolverV.cpp	/^struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };$/;"	f	struct:reduceDB_lt
operator ()	sat/SortV.h	/^    bool operator () (T x, T y) { return x < y; }$/;"	f	struct:LessThan_default
operator ()	sat/VarOrderV.h	/^    bool operator () (Var x, Var y) { return activity[x] > activity[y]; }$/;"	f	struct:VarOrder_lt
operator <	sat/SolverTypesV.h	/^inline bool operator <  (Lit p, Lit q) { return index(p)  < index(q); }  \/\/ '<' guarantees that p, ~p are adjacent in the ordering.$/;"	f
operator <=	sat/GlobalV.h	/^template <class T> static inline bool operator <= (const T& x, const T& y) { return !(y < x);  }$/;"	f
operator =	sat/GlobalV.h	/^vec<T>& vec<T>::operator = (const vec<T>& other){$/;"	f	class:vec
operator =	sat/SolverTypesV.h	/^	inline void operator = (int n) { x = n; }$/;"	f	class:Lit
operator =	util/unate.h	/^  Unateness& operator = (const Unateness& u) { val_ = u.val_; return (*this); }$/;"	f	class:Unateness
operator ==	sat/GlobalV.h	/^    bool  operator == (const lbool& other) const { return value == other.value; }$/;"	f	class:lbool
operator ==	sat/SolverTypesV.h	/^    bool        operator == (GClause c) const { return data == c.data; }$/;"	f	class:GClause
operator ==	sat/SolverTypesV.h	/^inline bool operator == (Lit p, Lit q) { return index(p) == index(q); }$/;"	f
operator ==	util/bool3v.h	/^  bool operator == (bool_3v b) const {$/;"	f	class:bool_3v
operator ==	util/unate.h	/^  bool operator == (const Unateness& u) const { return val_ == u.val_; }$/;"	f	class:Unateness
operator >	sat/GlobalV.h	/^template <class T> static inline bool operator >  (const T& x, const T& y) { return y < x;     }$/;"	f
operator >=	sat/GlobalV.h	/^template <class T> static inline bool operator >= (const T& x, const T& y) { return !(x < y);  }$/;"	f
operator T*	sat/GlobalV.h	/^    operator T*       (void)           { return data; }     \/\/ (unsafe but convenient)$/;"	f	class:vec
operator []	sat/GlobalV.h	/^    T&       operator [] (int index)        { return data[index]; }$/;"	f	class:vec
operator []	sat/GlobalV.h	/^    const T& operator [] (int index) const  { return data[index]; }$/;"	f	class:vec
operator []	sat/SolverTypesV.h	/^    Lit       operator [] (int i) const { return data[i]; }$/;"	f	class:Clause
operator []	sat/SolverTypesV.h	/^    Lit&      operator [] (int i)       { return data[i]; }$/;"	f	class:Clause
operator ^	util/bool3v.h	/^  bool_3v operator ^ (bool_3v b) const {$/;"	f	class:bool_3v
operator const T*	sat/GlobalV.h	/^    operator const T* (void) const     { return data; }$/;"	f	class:vec
operator |	util/unate.h	/^  Unateness operator | (Unateness u) { return Unateness(val_ | u.val_); }$/;"	f	class:Unateness
operator ||	util/bool3v.h	/^  bool_3v operator || (bool_3v b) const {$/;"	f	class:bool_3v
operator ~	sat/GlobalV.h	/^    lbool operator ~  (void)               const { return lbool(-value); }$/;"	f	class:lbool
operator ~	sat/SolverTypesV.h	/^inline Lit operator ~ (Lit p) { Lit q; q.x = p.x ^ 1; return q; }$/;"	f
operator ~	util/unate.h	/^  Unateness operator ~() { return Unateness((0xd8 >> (val_ << 1)) & 3); }$/;"	f	class:Unateness
order	sat/SolverV.h	/^    VarOrder            order;            \/\/ Keeps track of the decision variable order.$/;"	m	class:SolverV
overall_pos	cir/reader.h	/^	unsigned int	overall_pos;$/;"	m	class:Reader
overall_pos	sat/reader.h	/^	unsigned int	overall_pos;$/;"	m	class:Reader
own_fd	sat/FileV.h	/^    bool        own_fd;     \/\/ Do we own the file descriptor? If so, will close file in destructor.$/;"	m	class:File
parent	sat/HeapV.h	/^static inline int parent(int i) { return i >> 1; }$/;"	f
parse	cir/cirParse.cpp	/^bool CirNet::parse(const std::string& filename) {$/;"	f	class:CirNet
percolateDown	sat/HeapV.h	/^    inline void percolateDown(int i)$/;"	f	class:Heap
percolateUp	sat/HeapV.h	/^    inline void percolateUp(int i)$/;"	f	class:Heap
pop	sat/GlobalV.h	/^    void     pop    (void)             { sz--, data[sz].~T(); }$/;"	f	class:vec
pos	cir/reader.h	/^	unsigned int	pos;$/;"	m	class:Reader
pos	sat/FileV.h	/^    int         pos;        \/\/ Current position in buffer$/;"	m	class:File
pos	sat/reader.h	/^	unsigned int	pos;$/;"	m	class:Reader
progressEstimate	sat/SolverV.cpp	/^double SolverV::progressEstimate()$/;"	f	class:SolverV
progress_estimate	sat/SolverV.h	/^    double      progress_estimate;  \/\/ Set by 'search()'.$/;"	m	class:SolverV
proof	sat/SolverV.h	/^    Proof*          proof;              \/\/ Set this directly after constructing 'Solver' to enable proof logging. Initialized to NULL.$/;"	m	class:SolverV
proof_logged	sat/SolverV.h	/^    bool    proof_logged() { return false; }$/;"	f	class:SolverV
propagate	sat/SolverV.cpp	/^Clause* SolverV::propagate()$/;"	f	class:SolverV
propagate_tmpbin	sat/SolverV.h	/^    Clause*             propagate_tmpbin;$/;"	m	class:SolverV
propagations	sat/SolverV.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
push	sat/GlobalV.h	/^    void     push  (const T& elem)     { if (sz == cap) grow(sz+1); new (&data[sz]) T(elem); sz++; }$/;"	f	class:vec
push	sat/GlobalV.h	/^    void     push  (void)              { if (sz == cap) grow(sz+1); new (&data[sz]) T()    ; sz++; }$/;"	f	class:vec
pushBackFanin	cir/cirGate.h	/^	void pushBackFanin(CirGateV gateV) 				{ _in.push_back(gateV); }$/;"	f	class:CirGate
pushBackFanout	cir/cirGate.h	/^	void pushBackFanout(CirGateV gateV) 			{ _out.push_back(gateV); }$/;"	f	class:CirGate
putChar	sat/FileV.h	/^    int putChar(int chr) {$/;"	f	class:File
putCharQ	sat/FileV.h	/^    int putCharQ(int chr) {         \/\/ Quick version with minimal overhead -- don't call this in the wrong mode!$/;"	f	class:File
putInt	sat/FileV.h	/^static inline void   putInt  (File& out, int64 val) { putUInt(out, encode64(val)); }$/;"	f
putUInt	sat/FileV.cpp	/^void putUInt(File& out, uint64 val)$/;"	f
qhead	sat/SolverV.h	/^    int                 qhead;            \/\/ Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).$/;"	m	class:SolverV
random_seed	sat/VarOrderV.h	/^    double              random_seed; \/\/ For the internal random number generator$/;"	m	class:VarOrder
random_var_freq	sat/SolverV.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
readUntil	util/parse.h	/^std::string readUntil(std::ifstream& ifs, char end) {$/;"	f
readVerilog	cir/cirParse.cpp	/^CirMgr::readVerilog(const string& filename, bool isF)$/;"	f	class:CirMgr
reason	sat/SolverV.h	/^    vec<Clause*>        reason;           \/\/ 'reason[var]' is the clause that implied the variables current value, or 'NULL' if none.$/;"	m	class:SolverV
reduceDB	sat/SolverV.cpp	/^void SolverV::reduceDB()$/;"	f	class:SolverV
reduceDB_lt	sat/SolverV.cpp	/^struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };$/;"	s	file:
release	sat/GlobalV.h	/^    T*       release  (void)           { T* ret = data; data = NULL; sz = 0; cap = 0; return ret; }$/;"	f	class:vec
releaseDescriptor	sat/FileV.h	/^    int releaseDescriptor(void) {   \/\/ Don't run UNIX function 'close()' on descriptor in 'File's 'close()'.$/;"	f	class:File
remove	sat/SolverV.cpp	/^void SolverV::remove(Clause* c, bool just_dealloc)$/;"	f	class:SolverV
removeComment	cir/cirParse.cpp	/^bool CirMgr::removeComment(const std::string& inFilename,$/;"	f	class:CirMgr
removeWatch	sat/SolverV.cpp	/^void removeWatch(vec<Clause*>& ws, Clause* elem)$/;"	f
report	cir/cirGate.cpp	/^CirAndGate::report() const$/;"	f	class:CirAndGate
report	cir/cirGate.cpp	/^CirBufGate::report() const$/;"	f	class:CirBufGate
report	cir/cirGate.cpp	/^CirConstGate::report() const$/;"	f	class:CirConstGate
report	cir/cirGate.cpp	/^CirErrorGate::report() const$/;"	f	class:CirErrorGate
report	cir/cirGate.cpp	/^CirInvGate::report() const$/;"	f	class:CirInvGate
report	cir/cirGate.cpp	/^CirMuxGate::report() const$/;"	f	class:CirMuxGate
report	cir/cirGate.cpp	/^CirNandGate::report() const$/;"	f	class:CirNandGate
report	cir/cirGate.cpp	/^CirNorGate::report() const$/;"	f	class:CirNorGate
report	cir/cirGate.cpp	/^CirOrGate::report() const$/;"	f	class:CirOrGate
report	cir/cirGate.cpp	/^CirPiGate::report() const$/;"	f	class:CirPiGate
report	cir/cirGate.cpp	/^CirPoGate::report() const$/;"	f	class:CirPoGate
report	cir/cirGate.cpp	/^CirXnorGate::report() const$/;"	f	class:CirXnorGate
report	cir/cirGate.cpp	/^CirXorGate::report() const$/;"	f	class:CirXorGate
report	util/myUsage.h	/^   void report(bool repTime, bool repMem) {$/;"	f	class:MyUsage
reportCandList	cir/cirReport.cpp	/^CirMgr::reportCandList() const$/;"	f	class:CirMgr
reportGateAll	cir/cirReport.cpp	/^CirNet::reportGateAll() const$/;"	f	class:CirNet
reportMuxAssignment	cir/cirReport.cpp	/^CirMgr::reportMuxAssignment() const$/;"	f	class:CirMgr
reportNetList	cir/cirReport.cpp	/^CirNet::reportNetList() const$/;"	f	class:CirNet
reportNetListRec	cir/cirReport.cpp	/^CirNet::reportNetListRec(CirGate* g, unsigned level) const$/;"	f	class:CirNet
reportSortedCand	cir/cirReport.cpp	/^CirMgr::reportSortedCand() const$/;"	f	class:CirMgr
reportTopoList	cir/cirReport.cpp	/^CirNet::reportTopoList() const$/;"	f	class:CirNet
reportf	sat/SolverV.h	28;"	d
reserveFormula	sat/sat.h	/^      inline const size_t reserveFormula() { return getPosVar(newVar()); }$/;"	f	class:SatSolverV
reset	sat/sat.cpp	/^void SatSolverV::reset()$/;"	f	class:SatSolverV
reset	util/myUsage.h	/^   void reset() {$/;"	f	class:MyUsage
resolve	sat/ProofV.cpp	/^void Proof::resolve(ClauseId next, Var x)$/;"	f	class:Proof
restoreTiedGates	cir/cirCost.cpp	/^CirMgr::restoreTiedGates()$/;"	f	class:CirMgr
retrieveProof	cir/cirSat.cpp	/^CirMgr::retrieveProof( Reader& rdr, vector<unsigned>& clausePos, vector<ClauseId>& usedClause )$/;"	f	class:CirMgr
right	sat/HeapV.h	/^static inline int right (int i) { return i+i + 1; }$/;"	f
root	sat/ProofV.h	/^    virtual void root   (const vec<Lit>& c) {}$/;"	f	struct:ProofTraverser
root_cla_count	sat/SolverV.h	/^   int      root_cla_count;$/;"	m	class:SolverV
root_level	sat/SolverV.h	/^    int                 root_level;       \/\/ Level of first proper decision.$/;"	m	class:SolverV
save	sat/ProofV.cpp	/^bool Proof::save(cchar* filename)$/;"	f	class:Proof
search	sat/SolverV.cpp	/^lbool SolverV::search(int nof_conflicts, int nof_learnts, const SearchParams& params)$/;"	f	class:SolverV
seek	cir/reader.cpp	/^void Reader::seek( const unsigned int to ){$/;"	f	class:Reader
seek	sat/FileV.cpp	/^void File::seek(int64 file_pos, int whence)$/;"	f	class:File
seek	sat/reader.cpp	/^void Reader::seek( const unsigned int to ){$/;"	f	class:Reader
select	sat/VarOrderV.h	/^Var VarOrder::select(double random_var_freq)$/;"	f	class:VarOrder
selectionSort	sat/SortV.h	/^template <class T> static inline void selectionSort(T* array, int size) {$/;"	f
selectionSort	sat/SortV.h	/^void selectionSort(T* array, int size, LessThan lt)$/;"	f
setBounds	sat/HeapV.h	/^    void setBounds (int size) { assert(size >= 0); indices.growTo(size,0); }$/;"	f	class:Heap
setCostVar	cir/cirGate.h	/^	void setCostVar(Var v)			{ _costVar = v; }$/;"	f	class:CirGate
setFanin	cir/cirGate.h	/^	void setFanin(CirGateV gateV, unsigned idx) 	{ assert(idx < _in.size()); _in[idx] = gateV; }$/;"	f	class:CirGate
setFaninSize	cir/cirGate.h	/^	void setFaninSize(unsigned s) 					{ _in.resize(s); }$/;"	f	class:CirGate
setFanout	cir/cirGate.h	/^	void setFanout(CirGateV gateV, unsigned idx) { assert(idx < _out.size()); _out[idx] = gateV; }$/;"	f	class:CirGate
setFanoutSize	cir/cirGate.h	/^	void setFanoutSize(unsigned s) 					{ _out.resize(s); }$/;"	f	class:CirGate
setId	cir/cirGate.h	/^	void setId(unsigned i) 			{ _id = i; }$/;"	f	class:CirGate
setInv	cir/cirGate.h	/^	void setInv() 				{ _gateV |= (size_t)INV_MASK; }$/;"	f	class:CirGateV
setMemUsage	util/myUsage.h	/^   void setMemUsage() { _currentMem = checkMem() - _initMem; }$/;"	f	class:MyUsage
setMode	sat/FileV.h	/^    void setMode(FileMode m) {$/;"	f	class:File
setName	cir/cirMgr.h	/^	void setName(const string& n ) 	{ _name = n; }$/;"	f	class:CirMgr
setName	cir/cirNet.h	/^	void setName(const string& n )					{ _name = n; }$/;"	f	class:CirNet
setTimeUsage	util/myUsage.h	/^   void setTimeUsage() {$/;"	f	class:MyUsage
setToRef	cir/cirGate.h	/^	void setToRef() 				{ _ref = _globalRef; }$/;"	f	class:CirGate
setVar	cir/cirGate.h	/^	void setVar(Var v)				{ _var = v; }$/;"	f	class:CirGate
setWeight	cir/cirGate.h	/^    void setWeight(unsigned w)	{ _weight = w; }$/;"	f	class:CirGate
shrink	sat/GlobalV.h	/^    void     shrink (int nelems)       { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }$/;"	f	class:vec
sign	sat/SolverTypesV.h	/^inline bool sign  (Lit p) { return p.x & 1; }$/;"	f
simpDB_assigns	sat/SolverV.h	/^    int                 simpDB_assigns;   \/\/ Number of top-level assignments since last execution of 'simplifyDB()'.$/;"	m	class:SolverV
simpDB_props	sat/SolverV.h	/^    int64               simpDB_props;     \/\/ Remaining number of propagations that must be made before next execution of 'simplifyDB()'.$/;"	m	class:SolverV
simplify	sat/SolverV.cpp	/^bool SolverV::simplify(Clause* c) const$/;"	f	class:SolverV
simplify	sat/sat.cpp	/^const bool SatSolverV::simplify() { return _solver->simplifyDB(); }$/;"	f	class:SatSolverV
simplifyDB	sat/SolverV.cpp	/^bool SolverV::simplifyDB()$/;"	f	class:SolverV
size	cir/reader.h	/^	unsigned int 	size;$/;"	m	class:Reader
size	sat/FileV.h	/^    int         size;       \/\/ Size of buffer (at end of file, less than 'File_BufSize').$/;"	m	class:File
size	sat/GlobalV.h	/^    int      size   (void) const       { return sz; }$/;"	f	class:vec
size	sat/SolverTypesV.h	/^    int       size        ()      const { return size_learnt >> 1; }$/;"	f	class:Clause
size	sat/reader.h	/^	unsigned int 	size;$/;"	m	class:Reader
size_learnt	sat/SolverTypesV.h	/^    uint    size_learnt;$/;"	m	class:Clause
solve	cir/cirMgr.h	/^	bool solve() { return _s -> solve(); }$/;"	f	class:CirMgr
solve	sat/SolverV.cpp	/^bool SolverV::solve(const vec<Lit>& assumps)$/;"	f	class:SolverV
solve	sat/SolverV.h	/^    bool    solve() { vec<Lit> tmp; return solve(tmp); }$/;"	f	class:SolverV
solve	sat/sat.cpp	/^const bool SatSolverV::solve()$/;"	f	class:SatSolverV
solveLimited	sat/SolverV.cpp	/^lbool SolverV::solveLimited(const vec<Lit>& assumps, int64_t nConflicts)$/;"	f	class:SolverV
solveLimited	sat/SolverV.h	/^    lbool   solveLimited(int64_t nConflicts) { vec<Lit> tmp; return solveLimited(nConflicts); }$/;"	f	class:SolverV
sort	sat/SortV.h	/^template <class T, class LessThan> void sort(T* array, int size, LessThan lt) {$/;"	f
sort	sat/SortV.h	/^template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {$/;"	f
sort	sat/SortV.h	/^template <class T> static inline void sort(T* array, int size) {$/;"	f
sort	sat/SortV.h	/^template <class T> void sort(vec<T>& v) {$/;"	f
sort	sat/SortV.h	/^void sort(T* array, int size, LessThan lt, double& seed)$/;"	f
sortCandidate	cir/cirCost.cpp	/^CirMgr::sortCandidate()$/;"	f	class:CirMgr
sortGateByWeight	cir/cirCost.cpp	/^bool sortGateByWeight(CirGate* a, CirGate* b)$/;"	f
sortUnique	sat/SortV.h	/^template <class T, class LessThan> void sortUnique(vec<T>& v, LessThan lt) {$/;"	f
sortUnique	sat/SortV.h	/^template <class T> static inline void sortUnique(T* array, int& size) {$/;"	f
sortUnique	sat/SortV.h	/^template <class T> void sortUnique(vec<T>& v) {$/;"	f
sortUnique	sat/SortV.h	/^void sortUnique(T* array, int& size, LessThan lt)$/;"	f
split	util/parse.h	/^std::vector<std::string> split(const std::string& str, const std::string& sep) {$/;"	f
start_proof_logging	sat/SolverV.h	/^    bool    start_proof_logging() { return false; }$/;"	f	class:SolverV
starts	sat/SolverV.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
stats	sat/SolverV.h	/^    SolverStats     stats;$/;"	m	class:SolverV
str2Int	util/parse.h	/^bool str2Int(const std::string& str, int& num) {$/;"	f
sweep	cir/cirNet.cpp	/^CirNet::sweep()$/;"	f	class:CirNet
sz	sat/GlobalV.h	/^    int sz;$/;"	m	class:vec
tell	sat/FileV.cpp	/^int64 File::tell(void)$/;"	f	class:File
temp_files	sat/ProofV.cpp	/^static TempFiles temp_files;       \/\/ (should be singleton)$/;"	v	file:
test	cir/cirMgr.cpp	/^CirMgr::test()$/;"	f	class:CirMgr
tieGate	cir/cirSat.cpp	/^CirMgr::tieGate(CirGate* g1, CirGate* g2)$/;"	f	class:CirMgr
tieGateWithAssignment	cir/cirCost.cpp	/^CirMgr::tieGateWithAssignment(const std::vector<bool>& assign)$/;"	f	class:CirMgr
tiePi	cir/cirSat.cpp	/^CirMgr::tiePi(CirNet* f, CirNet* g)$/;"	f	class:CirMgr
toDimacs	sat/SolverTypesV.h	/^inline int toDimacs(Lit p) { return sign(p) ? -var(p) - 1 : var(p) + 1; }$/;"	f
toInt	sat/GlobalV.h	/^    int toInt(void) const { return value; }$/;"	f	class:lbool
toInt	sat/GlobalV.h	/^inline int   toInt  (lbool l) { return l.toInt(); }$/;"	f
toLbool	sat/GlobalV.h	/^inline lbool toLbool(int   v) { return lbool(v);  }$/;"	f
toLit	sat/SolverTypesV.h	/^inline Lit  toLit (int i) { Lit p; p.x = i; return p; }  \/\/ Inverse of 'index()'.$/;"	f
tot_literals	sat/SolverV.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
trail	sat/SolverV.h	/^    vec<Lit>            trail;            \/\/ Assignment stack; stores all assigments made in the order they were made.$/;"	m	class:SolverV
trail_lim	sat/SolverV.h	/^    vec<int>            trail_lim;        \/\/ Separator indices for different decision levels in 'trail[]'.$/;"	m	class:SolverV
trail_pos	sat/SolverV.cpp	/^    const vec<int>& trail_pos;$/;"	m	class:lastToFirst_lt	file:
trail_pos	sat/SolverV.h	/^    vec<int>            trail_pos;        \/\/ 'trail_pos[var]' is the variable's position in 'trail[]'. This supersedes 'level[]' in some sense, and 'level[]' will probably be removed in future releases.$/;"	m	class:SolverV
trav	sat/ProofV.h	/^    ProofTraverser* trav;$/;"	m	class:Proof
traverse	sat/ProofV.cpp	/^void Proof::traverse(ProofTraverser& trav, ClauseId goal)$/;"	f	class:Proof
uchar	sat/GlobalV.h	/^typedef unsigned char uchar;$/;"	t
uint64	sat/GlobalV.h	/^typedef UINT64             uint64;$/;"	t
uint64	sat/GlobalV.h	/^typedef unsigned long long uint64;$/;"	t
uintp	sat/GlobalV.h	/^typedef UINT_PTR           uintp;$/;"	t
uintp	sat/GlobalV.h	/^typedef unsigned __PTRDIFF_TYPE__ uintp;$/;"	t
undo	sat/VarOrderV.h	/^void VarOrder::undo(Var x)$/;"	f	class:VarOrder
unit_id	sat/SolverV.h	/^    vec<ClauseId>       unit_id;          \/\/ 'unit_id[var]' is the clause ID for the unit literal 'var' or '~var' (if set at toplevel).$/;"	m	class:SolverV
unsign	sat/SolverTypesV.h	/^inline Lit  unsign(Lit p) { Lit q; q.x = p.x & ~1; return q; }$/;"	f
update	sat/VarOrderV.h	/^void VarOrder::update(Var x)$/;"	f	class:VarOrder
updateIndices	cir/cirCost.cpp	/^CirMgr::updateIndices(std::vector<unsigned>& indices, unsigned& currCost)$/;"	f	class:CirMgr
val_	util/unate.h	/^  unsigned val_;$/;"	m	class:Unateness
value	sat/GlobalV.h	/^    int     value;$/;"	m	class:lbool
value	sat/SolverV.h	/^    lbool   value(Lit p) const { return sign(p) ? ~toLbool(assigns[var(p)]) : toLbool(assigns[var(p)]); }$/;"	f	class:SolverV
value	sat/SolverV.h	/^    lbool   value(Var x) const { return toLbool(assigns[x]); }$/;"	f	class:SolverV
value	util/bool3v.h	/^  unsigned value;$/;"	m	class:bool_3v
var	sat/SolverTypesV.h	/^inline int  var   (Lit p) { return p.x >> 1; }$/;"	f
varBumpActivity	sat/SolverV.h	/^    void     varBumpActivity(Lit p) {$/;"	f	class:SolverV
varDecayActivity	sat/SolverV.h	/^    void     varDecayActivity  () { if (var_decay >= 0) var_inc *= var_decay; }$/;"	f	class:SolverV
varI1G	cir/cirProof.cpp	/^VarMap varI1G;$/;"	v
varI2F	cir/cirProof.cpp	/^VarMap varI2F;$/;"	v
varI2G	cir/cirProof.cpp	/^VarMap varI2G;$/;"	v
varRescaleActivity	sat/SolverV.cpp	/^void SolverV::varRescaleActivity()$/;"	f	class:SolverV
var_Undef	sat/SolverTypesV.h	37;"	d
var_decay	sat/SolverV.h	/^    double              var_decay;        \/\/ INVERSE decay factor for variable activity: stores 1\/decay. Use negative value for static variable order.$/;"	m	class:SolverV
var_decay	sat/SolverV.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
var_inc	sat/SolverV.h	/^    double              var_inc;          \/\/ Amount to bump next variable with.$/;"	m	class:SolverV
vec	sat/GlobalV.h	/^             vec        (vec<T>& other) { TEMPLATE_FAIL; }$/;"	f	class:vec
vec	sat/GlobalV.h	/^    vec(T* array, int size)     : data(array), sz(size), cap(size) { }      \/\/ (takes ownership of array -- will be deallocated with 'xfree()')$/;"	f	class:vec
vec	sat/GlobalV.h	/^    vec(int size)               : data(NULL) , sz(0)   , cap(0)    { growTo(size); }$/;"	f	class:vec
vec	sat/GlobalV.h	/^    vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }$/;"	f	class:vec
vec	sat/GlobalV.h	/^    vec(void)                   : data(NULL) , sz(0)   , cap(0)    { }$/;"	f	class:vec
vec	sat/GlobalV.h	/^class vec {$/;"	c
verbosity	sat/SolverV.h	/^    int             verbosity;          \/\/ Verbosity level. 0=silent, 1=some progress report, 2=everything$/;"	m	class:SolverV
version_info	sat/SolverV.h	/^    inline const char* version_info() const { return "MINISAT Ver. 2.2"; }$/;"	f	class:SolverV
watches	sat/SolverV.h	/^    vec<vec<Clause*> >  watches;          \/\/ 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).$/;"	m	class:SolverV
x	sat/SolverTypesV.h	/^    int     x;$/;"	m	class:Lit
xfree	sat/GlobalV.h	/^template<class T> static inline void xfree(T *ptr) {$/;"	f
xmalloc	sat/GlobalV.h	/^template<class T> static inline T* xmalloc(size_t size) {$/;"	f
xrealloc	sat/GlobalV.h	/^template<class T> static inline T* xrealloc(T* ptr, size_t size) {$/;"	f
~CirGate	cir/cirGate.h	/^	virtual ~CirGate() {}$/;"	f	class:CirGate
~CirGateV	cir/cirGate.h	/^	~CirGateV() {}$/;"	f	class:CirGateV
~CirMgr	cir/cirMgr.h	/^	~CirMgr() {}\/\/{ delete _F; delete _G; delete _patch; }$/;"	f	class:CirMgr
~CirNet	cir/cirNet.cpp	/^CirNet::~CirNet()$/;"	f	class:CirNet
~File	sat/FileV.h	/^   ~File(void) {$/;"	f	class:File
~ProofTraverser	sat/ProofV.h	/^    virtual ~ProofTraverser() {}$/;"	f	struct:ProofTraverser
~Reader	cir/reader.cpp	/^Reader::~Reader(){$/;"	f	class:Reader
~Reader	sat/reader.cpp	/^Reader::~Reader(){$/;"	f	class:Reader
~SatSolverV	sat/sat.cpp	/^SatSolverV::~SatSolverV() $/;"	f	class:SatSolverV
~SolverV	sat/SolverV.h	/^   ~SolverV() {$/;"	f	class:SolverV
~TempFiles	sat/ProofV.cpp	/^   ~TempFiles()$/;"	f	class:TempFiles
~Unateness	util/unate.h	/^  ~Unateness() {}$/;"	f	class:Unateness
~vec	sat/GlobalV.h	/^   ~vec(void)                                                      { clear(true); }$/;"	f	class:vec
