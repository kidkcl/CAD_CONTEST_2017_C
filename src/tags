!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BoolOption	minisat/Options.h	/^    BoolOption(const char* c, const char* n, const char* d, bool v) $/;"	f	class:Minisat::BoolOption
BoolOption	minisat/Options.h	/^class BoolOption : public Option$/;"	c	namespace:Minisat
CIRMGR_H	cir/cirMgr.h	3;"	d
CIRNET_H	cir/cirNet.h	3;"	d
CIR_GATE_H	cir/cirGate.h	4;"	d
CMap	minisat/SolverTypes.h	/^class CMap$/;"	c	namespace:Minisat
CRef	minisat/SolverTypes.h	/^typedef RegionAllocator<uint32_t>::Ref CRef;$/;"	t	namespace:Minisat
CRefHash	minisat/SolverTypes.h	/^    struct CRefHash {$/;"	s	class:Minisat::CMap
CRef_Undef	minisat/SolverTypes.h	/^const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;$/;"	m	namespace:Minisat
CirAndGate	cir/cirGate.h	/^CirGateType(CirAndGate);$/;"	v
CirBufGate	cir/cirGate.h	/^CirGateType(CirBufGate);$/;"	v
CirConstGate	cir/cirGate.h	/^CirGateType(CirConstGate);$/;"	v
CirErrorGate	cir/cirGate.h	/^CirGateType(CirErrorGate);$/;"	v
CirGate	cir/cirGate.h	/^	CirGate(const string& name = "", unsigned id = 0): $/;"	f	class:CirGate
CirGate	cir/cirGate.h	/^class CirGate$/;"	c
CirGateType	cir/cirGate.h	100;"	d
CirGateV	cir/cirGate.h	/^	explicit CirGateV(CirGate* g = 0, bool inv = false): _gateV((size_t)g) {$/;"	f	class:CirGateV
CirGateV	cir/cirGate.h	/^class CirGateV$/;"	c
CirInvGate	cir/cirGate.h	/^CirGateType(CirInvGate);$/;"	v
CirMgr	cir/cirMgr.h	/^	explicit CirMgr(const string& name = ""): _name(name), _F(NULL), _G(NULL), _patch(NULL) {}$/;"	f	class:CirMgr
CirMgr	cir/cirMgr.h	/^class CirMgr$/;"	c
CirNandGate	cir/cirGate.h	/^CirGateType(CirNandGate);$/;"	v
CirNet	cir/cirNet.h	/^	explicit CirNet(const string& name = "", unsigned id = 0): $/;"	f	class:CirNet
CirNet	cir/cirNet.h	/^class CirNet$/;"	c
CirNorGate	cir/cirGate.h	/^CirGateType(CirNorGate);$/;"	v
CirOrGate	cir/cirGate.h	/^CirGateType(CirOrGate);$/;"	v
CirPiGate	cir/cirGate.h	/^CirGateType(CirPiGate);$/;"	v
CirPoGate	cir/cirGate.h	/^CirGateType(CirPoGate);$/;"	v
CirXnorGate	cir/cirGate.h	/^CirGateType(CirXnorGate);$/;"	v
CirXorGate	cir/cirGate.h	/^CirGateType(CirXorGate);$/;"	v
Clause	minisat/SolverTypes.h	/^    Clause(const Clause& from, bool use_extra){$/;"	f	class:Minisat::Clause
Clause	minisat/SolverTypes.h	/^    Clause(const vec<Lit>& ps, bool use_extra, bool learnt) {$/;"	f	class:Minisat::Clause
Clause	minisat/SolverTypes.h	/^class Clause {$/;"	c	namespace:Minisat
ClauseAllocator	minisat/SolverTypes.h	/^    ClauseAllocator() : extra_clause_field(false){}$/;"	f	class:Minisat::ClauseAllocator
ClauseAllocator	minisat/SolverTypes.h	/^    ClauseAllocator(uint32_t start_cap) : ra(start_cap), extra_clause_field(false){}$/;"	f	class:Minisat::ClauseAllocator
ClauseAllocator	minisat/SolverTypes.h	/^class ClauseAllocator$/;"	c	namespace:Minisat
ClauseIterator	minisat/SolverTypes.h	/^    ClauseIterator(const ClauseAllocator& _ca, const CRef* _crefs) : ca(_ca), crefs(_crefs){}$/;"	f	class:Minisat::ClauseIterator
ClauseIterator	minisat/SolverTypes.h	/^class ClauseIterator {$/;"	c	namespace:Minisat
DeepEqual	minisat/Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };$/;"	s	namespace:Minisat
DeepHash	minisat/Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };$/;"	s	namespace:Minisat
DoubleOption	minisat/Options.h	/^    DoubleOption(const char* c, const char* n, const char* d, double def = double(), DoubleRange r = DoubleRange(-HUGE_VAL, false, HUGE_VAL, false))$/;"	f	class:Minisat::DoubleOption
DoubleOption	minisat/Options.h	/^class DoubleOption : public Option$/;"	c	namespace:Minisat
DoubleRange	minisat/Options.h	/^    DoubleRange(double b, bool binc, double e, bool einc) : begin(b), end(e), begin_inclusive(binc), end_inclusive(einc) {}$/;"	f	struct:Minisat::DoubleRange
DoubleRange	minisat/Options.h	/^struct DoubleRange {$/;"	s	namespace:Minisat
Equal	minisat/Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };$/;"	s	namespace:Minisat
GateList	cir/cirGate.h	/^typedef vector<CirGate*> GateList;$/;"	t
GateType	cir/cirGate.h	/^enum GateType$/;"	g
GateVList	cir/cirGate.h	/^typedef vector<CirGateV> GateVList;$/;"	t
Gate_And	cir/cirGate.h	/^	Gate_And,$/;"	e	enum:GateType
Gate_Buf	cir/cirGate.h	/^	Gate_Buf,$/;"	e	enum:GateType
Gate_Const	cir/cirGate.h	/^	Gate_Const,$/;"	e	enum:GateType
Gate_Error	cir/cirGate.h	/^	Gate_Error,$/;"	e	enum:GateType
Gate_Inv	cir/cirGate.h	/^	Gate_Inv,$/;"	e	enum:GateType
Gate_Nand	cir/cirGate.h	/^	Gate_Nand,$/;"	e	enum:GateType
Gate_Nor	cir/cirGate.h	/^	Gate_Nor,$/;"	e	enum:GateType
Gate_Or	cir/cirGate.h	/^	Gate_Or,$/;"	e	enum:GateType
Gate_Pi	cir/cirGate.h	/^	Gate_Pi,$/;"	e	enum:GateType
Gate_Po	cir/cirGate.h	/^	Gate_Po,$/;"	e	enum:GateType
Gate_UNDEF	cir/cirGate.h	/^	Gate_UNDEF$/;"	e	enum:GateType
Gate_Xnor	cir/cirGate.h	/^	Gate_Xnor,$/;"	e	enum:GateType
Gate_Xor	cir/cirGate.h	/^	Gate_Xor,$/;"	e	enum:GateType
Hash	minisat/Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };$/;"	s	namespace:Minisat
HashTable	minisat/SolverTypes.h	/^    typedef Map<CRef, T, CRefHash> HashTable;$/;"	t	class:Minisat::CMap
Heap	minisat/Heap.h	/^    Heap(const Comp& c, MkIndex _index = MkIndex()) : indices(_index), lt(c) {}$/;"	f	class:Minisat::Heap
Heap	minisat/Heap.h	/^class Heap {$/;"	c	namespace:Minisat
INV_MASK	cir/cirGate.h	13;"	d
Int64Option	minisat/Options.h	/^    Int64Option(const char* c, const char* n, const char* d, int64_t def = int64_t(), Int64Range r = Int64Range(INT64_MIN, INT64_MAX))$/;"	f	class:Minisat::Int64Option
Int64Option	minisat/Options.h	/^class Int64Option : public Option$/;"	c	namespace:Minisat
Int64Range	minisat/Options.h	/^    Int64Range(int64_t b, int64_t e) : begin(b), end(e) {}$/;"	f	struct:Minisat::Int64Range
Int64Range	minisat/Options.h	/^struct Int64Range {$/;"	s	namespace:Minisat
IntMap	minisat/IntMap.h	/^        explicit IntMap(MkIndex _index = MkIndex()) : index(_index){}$/;"	f	class:Minisat::IntMap
IntMap	minisat/IntMap.h	/^    class IntMap {$/;"	c	namespace:Minisat
IntOption	minisat/Options.h	/^    IntOption(const char* c, const char* n, const char* d, int32_t def = int32_t(), IntRange r = IntRange(INT32_MIN, INT32_MAX))$/;"	f	class:Minisat::IntOption
IntOption	minisat/Options.h	/^class IntOption : public Option$/;"	c	namespace:Minisat
IntRange	minisat/Options.h	/^    IntRange(int b, int e) : begin(b), end(e) {}$/;"	f	struct:Minisat::IntRange
IntRange	minisat/Options.h	/^struct IntRange {$/;"	s	namespace:Minisat
IntSet	minisat/IntMap.h	/^    class IntSet$/;"	c	namespace:Minisat
Key	minisat/Queue.h	/^    typedef T Key;$/;"	t	class:Minisat::Queue
LMap	minisat/SolverTypes.h	/^template<class T> class LMap : public IntMap<Lit, T, MkIndexLit>{};$/;"	c	namespace:Minisat
LSet	minisat/SolverTypes.h	/^class LSet : public IntSet<Lit, MkIndexLit>{};$/;"	c	namespace:Minisat
LessThan_default	minisat/Sort.h	/^struct LessThan_default {$/;"	s	namespace:Minisat
Lit	minisat/SolverTypes.h	/^struct Lit {$/;"	s	namespace:Minisat
MINISAT_SAT_H_	minisat/sat.h	9;"	d
MYCLK_TCK	util/myUsage.h	21;"	d
MYCLK_TCK	util/myUsage.h	22;"	d
MY_USAGE_H	util/myUsage.h	10;"	d
Map	minisat/Map.h	/^    Map () : table(NULL), cap(0), size(0) {}$/;"	f	class:Minisat::Map
Map	minisat/Map.h	/^    Map (const H& h, const E& e) : hash(h), equals(e), table(NULL), cap(0), size(0){}$/;"	f	class:Minisat::Map
Map	minisat/Map.h	/^class Map {$/;"	c	namespace:Minisat
Minisat	minisat/Alg.h	/^namespace Minisat {$/;"	n
Minisat	minisat/Alloc.h	/^namespace Minisat {$/;"	n
Minisat	minisat/Heap.h	/^namespace Minisat {$/;"	n
Minisat	minisat/IntMap.h	/^namespace Minisat {$/;"	n
Minisat	minisat/Map.h	/^namespace Minisat {$/;"	n
Minisat	minisat/Options.h	/^namespace Minisat {$/;"	n
Minisat	minisat/ParseUtils.h	/^namespace Minisat {$/;"	n
Minisat	minisat/Queue.h	/^namespace Minisat {$/;"	n
Minisat	minisat/Rnd.h	/^namespace Minisat {$/;"	n
Minisat	minisat/Solver.h	/^namespace Minisat {$/;"	n
Minisat	minisat/SolverTypes.h	/^namespace Minisat {$/;"	n
Minisat	minisat/Sort.h	/^namespace Minisat {$/;"	n
Minisat	minisat/System.h	/^namespace Minisat {$/;"	n
Minisat	minisat/Vec.h	/^namespace Minisat {$/;"	n
Minisat	minisat/XAlloc.h	/^namespace Minisat {$/;"	n
Minisat_Alg_h	minisat/Alg.h	22;"	d
Minisat_Alloc_h	minisat/Alloc.h	22;"	d
Minisat_Heap_h	minisat/Heap.h	22;"	d
Minisat_IntMap_h	minisat/IntMap.h	20;"	d
Minisat_IntTypes_h	minisat/IntTypes.h	21;"	d
Minisat_Map_h	minisat/Map.h	21;"	d
Minisat_Options_h	minisat/Options.h	21;"	d
Minisat_ParseUtils_h	minisat/ParseUtils.h	22;"	d
Minisat_Queue_h	minisat/Queue.h	22;"	d
Minisat_Rnd_h	minisat/Rnd.h	20;"	d
Minisat_SolverTypes_h	minisat/SolverTypes.h	23;"	d
Minisat_Solver_h	minisat/Solver.h	22;"	d
Minisat_Sort_h	minisat/Sort.h	22;"	d
Minisat_System_h	minisat/System.h	22;"	d
Minisat_Vec_h	minisat/Vec.h	22;"	d
Minisat_XAlloc_h	minisat/XAlloc.h	22;"	d
MkIndexDefault	minisat/IntMap.h	/^    template<class T> struct MkIndexDefault {$/;"	s	namespace:Minisat
MkIndexLit	minisat/SolverTypes.h	/^struct MkIndexLit { vec<Lit>::Size operator()(Lit l) const { return vec<Lit>::Size(l.x); } };$/;"	s	namespace:Minisat
MyUsage	util/myUsage.h	/^   MyUsage() { reset(); }$/;"	f	class:MyUsage
MyUsage	util/myUsage.h	/^class MyUsage$/;"	c
OccLists	minisat/SolverTypes.h	/^    OccLists(const Deleted& d, MkIndex _index = MkIndex()) :$/;"	f	class:Minisat::OccLists
OccLists	minisat/SolverTypes.h	/^class OccLists$/;"	c	namespace:Minisat
Option	minisat/Options.h	/^    Option(const char* name_, $/;"	f	class:Minisat::Option
Option	minisat/Options.h	/^class Option$/;"	c	namespace:Minisat
OptionLt	minisat/Options.h	/^    struct OptionLt {$/;"	s	class:Minisat::Option
OutOfMemoryException	minisat/XAlloc.h	/^class OutOfMemoryException{};$/;"	c	namespace:Minisat
Pair	minisat/Map.h	/^    struct Pair { K key; D data; };$/;"	s	class:Minisat::Map
Queue	minisat/Queue.h	/^    Queue() : buf(1), first(0), end(0) {}$/;"	f	class:Minisat::Queue
Queue	minisat/Queue.h	/^class Queue {$/;"	c	namespace:Minisat
RLIMIT_AS	minisat/System.cpp	114;"	d	file:
RLIMIT_AS	minisat/System.cpp	130;"	d	file:
Ref	minisat/Alloc.h	/^    typedef uint32_t Ref;$/;"	t	class:Minisat::RegionAllocator
Ref_Undef	minisat/Alloc.h	/^    enum { Ref_Undef = UINT32_MAX };$/;"	e	enum:Minisat::RegionAllocator::__anon1
RegionAllocator	minisat/Alloc.h	/^    explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }$/;"	f	class:Minisat::RegionAllocator
RegionAllocator	minisat/Alloc.h	/^class RegionAllocator$/;"	c	namespace:Minisat
SatSolver	minisat/sat.h	/^  SatSolver(): solver_(NULL) {}$/;"	f	class:SatSolver
SatSolver	minisat/sat.h	/^class SatSolver {$/;"	c
ShrinkStackElem	minisat/Solver.h	/^        ShrinkStackElem(uint32_t _i, Lit _l) : i(_i), l(_l){}$/;"	f	struct:Minisat::Solver::ShrinkStackElem
ShrinkStackElem	minisat/Solver.h	/^    struct ShrinkStackElem {$/;"	s	class:Minisat::Solver
Size	minisat/Vec.h	/^    typedef _Size Size;$/;"	t	class:Minisat::vec
Solver	minisat/Solver.cpp	/^Solver::Solver() :$/;"	f	class:Solver
Solver	minisat/Solver.h	/^class Solver {$/;"	c	namespace:Minisat
StreamBuffer	minisat/ParseUtils.h	/^    explicit StreamBuffer(gzFile i) : in(i), pos(0), size(0){$/;"	f	class:Minisat::StreamBuffer
StreamBuffer	minisat/ParseUtils.h	/^class StreamBuffer {$/;"	c	namespace:Minisat
StringOption	minisat/Options.h	/^    StringOption(const char* c, const char* n, const char* d, const char* def = NULL) $/;"	f	class:Minisat::StringOption
StringOption	minisat/Options.h	/^class StringOption : public Option$/;"	c	namespace:Minisat
TrailIterator	minisat/SolverTypes.h	/^    TrailIterator(const Lit* _lits) : lits(_lits){}$/;"	f	class:Minisat::TrailIterator
TrailIterator	minisat/SolverTypes.h	/^class TrailIterator {$/;"	c	namespace:Minisat
UTIL_BOOL3V_H_	util/bool3v.h	9;"	d
UTIL_MYSTRING_H_	util/myString.h	9;"	d
UTIL_PARSE_H_	util/parse.h	9;"	d
UTIL_UNATE_H_	util/unate.h	9;"	d
Unateness	util/unate.h	/^  Unateness(): val_(0) {}$/;"	f	class:Unateness
Unateness	util/unate.h	/^  Unateness(const Unateness& u) { val_ = u.val_; }$/;"	f	class:Unateness
Unateness	util/unate.h	/^  explicit Unateness(unsigned u): val_(u) {}$/;"	f	class:Unateness
Unateness	util/unate.h	/^class Unateness{$/;"	c
Unit_Size	minisat/Alloc.h	/^    enum { Unit_Size = sizeof(T) };$/;"	e	enum:Minisat::RegionAllocator::__anon2
Unit_Size	minisat/SolverTypes.h	/^    enum { Unit_Size = RegionAllocator<uint32_t>::Unit_Size };$/;"	e	enum:Minisat::ClauseAllocator::__anon6
VMap	minisat/SolverTypes.h	/^template<class T> class VMap : public IntMap<Var, T>{};$/;"	c	namespace:Minisat
Var	minisat/SolverTypes.h	/^typedef int Var;$/;"	t	namespace:Minisat
VarData	minisat/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	s	class:Minisat::Solver
VarOrderLt	minisat/Solver.h	/^        VarOrderLt(const IntMap<Var, double>&  act) : activity(act) { }$/;"	f	struct:Minisat::Solver::VarOrderLt
VarOrderLt	minisat/Solver.h	/^    struct VarOrderLt {$/;"	s	class:Minisat::Solver
Watcher	minisat/Solver.h	/^        Watcher(CRef cr, Lit p) : cref(cr), blocker(p) {}$/;"	f	struct:Minisat::Solver::Watcher
Watcher	minisat/Solver.h	/^    struct Watcher {$/;"	s	class:Minisat::Solver
WatcherDeleted	minisat/Solver.h	/^        WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}$/;"	f	struct:Minisat::Solver::WatcherDeleted
WatcherDeleted	minisat/Solver.h	/^    struct WatcherDeleted$/;"	s	class:Minisat::Solver
_F	cir/cirMgr.h	/^	CirNet*								_F;$/;"	m	class:CirMgr
_G	cir/cirMgr.h	/^	CirNet*								_G;$/;"	m	class:CirMgr
_cat	minisat/Solver.cpp	/^static const char* _cat = "CORE";$/;"	v	file:
_const0	cir/cirNet.h	/^	CirGate*							_const0;$/;"	m	class:CirNet
_const1	cir/cirNet.h	/^	CirGate*							_const1;$/;"	m	class:CirNet
_currentMem	util/myUsage.h	/^   double     _currentMem;$/;"	m	class:MyUsage
_currentTick	util/myUsage.h	/^   double     _currentTick;$/;"	m	class:MyUsage
_errorList	cir/cirNet.h	/^	GateList							_errorList;$/;"	m	class:CirNet
_gateList	cir/cirNet.h	/^	GateList							_gateList;$/;"	m	class:CirNet
_gateV	cir/cirGate.h	/^	size_t _gateV;$/;"	m	class:CirGateV
_globalRef	cir/cirGate.cpp	/^unsigned CirGate::_globalRef = 0;$/;"	m	class:CirGate	file:
_globalRef	cir/cirGate.h	/^	static unsigned 		_globalRef;$/;"	m	class:CirGate
_id	cir/cirGate.h	/^	unsigned				_id;$/;"	m	class:CirGate
_id	cir/cirNet.h	/^	unsigned 							_id;$/;"	m	class:CirNet
_in	cir/cirGate.h	/^	GateVList				_in;$/;"	m	class:CirGate
_initMem	util/myUsage.h	/^   double     _initMem;$/;"	m	class:MyUsage
_insert	minisat/Map.h	/^    void   _insert (const K& k, const D& d) { $/;"	f	class:Minisat::Map
_name	cir/cirGate.h	/^	string					_name;$/;"	m	class:CirGate
_name	cir/cirMgr.h	/^	string 								_name;$/;"	m	class:CirMgr
_name	cir/cirNet.h	/^	string								_name;$/;"	m	class:CirNet
_name2GateMap	cir/cirNet.h	/^	unordered_map<string, CirGate*>		_name2GateMap;$/;"	m	class:CirNet
_out	cir/cirGate.h	/^	GateVList				_out;	$/;"	m	class:CirGate
_patch	cir/cirMgr.h	/^	CirNet*								_patch;$/;"	m	class:CirMgr
_periodUsedTime	util/myUsage.h	/^   double     _periodUsedTime;$/;"	m	class:MyUsage
_piList	cir/cirNet.h	/^	GateList							_piList, _poList;$/;"	m	class:CirNet
_poList	cir/cirNet.h	/^	GateList							_piList, _poList;$/;"	m	class:CirNet
_ref	cir/cirGate.h	/^	mutable unsigned		_ref;$/;"	m	class:CirGate
_topoList	cir/cirNet.h	/^	GateList							_topoList;$/;"	m	class:CirNet
_totalUsedTime	util/myUsage.h	/^   double     _totalUsedTime;$/;"	m	class:MyUsage
abs	minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon5
abstractLevel	minisat/Solver.h	/^inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }$/;"	f	class:Minisat::Solver
abstraction	minisat/SolverTypes.h	/^    uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }$/;"	f	class:Minisat::Clause
act	minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon5
activity	minisat/Solver.h	/^        const IntMap<Var, double>&  activity;$/;"	m	struct:Minisat::Solver::VarOrderLt
activity	minisat/Solver.h	/^    VMap<double>        activity;         \/\/ A heuristic measurement of the activity of a variable.$/;"	m	class:Minisat::Solver
activity	minisat/SolverTypes.h	/^    float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }$/;"	f	class:Minisat::Clause
addAndCNF	minisat/sat.cpp	/^void SatSolver::addAndCNF(Var out, Var in0, bool inv0, Var in1, bool inv1) {$/;"	f	class:SatSolver
addClause	minisat/Solver.h	/^inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addClause	minisat/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addClause	minisat/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addClause	minisat/Solver.h	/^inline bool     Solver::addClause       (Lit p, Lit q, Lit r, Lit s){ add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); add_tmp.push(s); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addClause	minisat/Solver.h	/^inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addClause	minisat/sat.h	/^  void addClause(Lit lit0) { solver_->addClause(lit0); }$/;"	f	class:SatSolver
addClause	minisat/sat.h	/^  void addClause(Lit lit0, Lit lit1) { solver_->addClause(lit0, lit1); }$/;"	f	class:SatSolver
addClause	minisat/sat.h	/^  void addClause(Lit lit0, Lit lit1, Lit lit2) {$/;"	f	class:SatSolver
addClause	minisat/sat.h	/^  void addClause(const vec<Lit>& clause) { solver_->addClause(clause); }$/;"	f	class:SatSolver
addClause_	minisat/Solver.cpp	/^bool Solver::addClause_(vec<Lit>& ps)$/;"	f	class:Solver
addEmptyClause	minisat/Solver.h	/^inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }$/;"	f	class:Minisat::Solver
addEqCNF	minisat/sat.cpp	/^void SatSolver::addEqCNF(Var var0, Var var1, bool inv) {$/;"	f	class:SatSolver
addNeg	util/unate.h	/^  void addNeg() { val_ |= 2; }$/;"	f	class:Unateness
addPos	util/unate.h	/^  void addPos() { val_ |= 1; }$/;"	f	class:Unateness
addUnitCNF	minisat/sat.cpp	/^void SatSolver::addUnitCNF(Var var, bool val) {$/;"	f	class:SatSolver
addXorCNF	minisat/sat.cpp	/^void SatSolver::addXorCNF(Var out, Var in0, bool inv0, Var in1, bool inv1) {$/;"	f	class:SatSolver
add_tmp	minisat/Solver.h	/^    vec<Lit>            add_tmp;$/;"	m	class:Minisat::Solver
ael	minisat/Alloc.h	/^    Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);$/;"	f	class:Minisat::RegionAllocator
ael	minisat/SolverTypes.h	/^    CRef          ael       (const Clause* t){ return ra.ael((uint32_t*)t); }$/;"	f	class:Minisat::ClauseAllocator
alloc	minisat/Alloc.h	/^RegionAllocator<T>::alloc(int size)$/;"	f	class:Minisat::RegionAllocator
alloc	minisat/SolverTypes.h	/^    CRef alloc(const Clause& from)$/;"	f	class:Minisat::ClauseAllocator
alloc	minisat/SolverTypes.h	/^    CRef alloc(const vec<Lit>& ps, bool learnt = false)$/;"	f	class:Minisat::ClauseAllocator
analyze	minisat/Solver.cpp	/^void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)$/;"	f	class:Solver
analyzeFinal	minisat/Solver.cpp	/^void Solver::analyzeFinal(Lit p, LSet& out_conflict)$/;"	f	class:Solver
analyze_stack	minisat/Solver.h	/^    vec<ShrinkStackElem>analyze_stack;$/;"	m	class:Minisat::Solver
analyze_toclear	minisat/Solver.h	/^    vec<Lit>            analyze_toclear;$/;"	m	class:Minisat::Solver
append	minisat/Alg.h	/^static inline void append(const vec<T>& from, vec<T>& to){ copy(from, to, true); }$/;"	f	namespace:Minisat
assigns	minisat/Solver.h	/^    VMap<lbool>         assigns;          \/\/ The current assignments.$/;"	m	class:Minisat::Solver
assumptions	minisat/Solver.h	/^    vec<Lit>            assumptions;      \/\/ Current set of assumptions provided to solve by the user.$/;"	m	class:Minisat::Solver
assureLookahead	minisat/ParseUtils.h	/^    void assureLookahead() {$/;"	f	class:Minisat::StreamBuffer
asynch_interrupt	minisat/Solver.h	/^    bool                asynch_interrupt;$/;"	m	class:Minisat::Solver
attachClause	minisat/Solver.cpp	/^void Solver::attachClause(CRef cr){$/;"	f	class:Solver
begin	minisat/IntMap.h	/^        V*       begin  ()       { return &map[0]; }$/;"	f	class:Minisat::IntMap
begin	minisat/IntMap.h	/^        const V* begin  () const { return &map[0]; }$/;"	f	class:Minisat::IntMap
begin	minisat/Options.h	/^    double begin;$/;"	m	struct:Minisat::DoubleRange
begin	minisat/Options.h	/^    int begin;$/;"	m	struct:Minisat::IntRange
begin	minisat/Options.h	/^    int64_t begin;$/;"	m	struct:Minisat::Int64Range
begin_inclusive	minisat/Options.h	/^    bool  begin_inclusive;$/;"	m	struct:Minisat::DoubleRange
blocker	minisat/Solver.h	/^        Lit  blocker;$/;"	m	struct:Minisat::Solver::Watcher
bool_3v	util/bool3v.h	/^  bool_3v()                     : value(0) {}$/;"	f	class:bool_3v
bool_3v	util/bool3v.h	/^  explicit bool_3v(bool x)      : value(x) {}$/;"	f	class:bool_3v
bool_3v	util/bool3v.h	/^  explicit bool_3v(unsigned v)  : value(v) {}$/;"	f	class:bool_3v
bool_3v	util/bool3v.h	/^class bool_3v {$/;"	c
bucket	minisat/Map.h	/^    const vec<Pair>& bucket(int i) const { return table[i]; }$/;"	f	class:Minisat::Map
bucket	minisat/SolverTypes.h	/^    const vec<typename HashTable::Pair>& bucket(int i) const { return map.bucket(i); }$/;"	f	class:Minisat::CMap
bucket_count	minisat/Map.h	/^    int  bucket_count() const { return cap; }$/;"	f	class:Minisat::Map
bucket_count	minisat/SolverTypes.h	/^    int  bucket_count() const { return map.bucket_count(); }$/;"	f	class:Minisat::CMap
budgetOff	minisat/Solver.h	/^inline void     Solver::budgetOff(){ conflict_budget = propagation_budget = -1; }$/;"	f	class:Minisat::Solver
buf	minisat/ParseUtils.h	/^    unsigned char* buf;$/;"	m	class:Minisat::StreamBuffer
buf	minisat/Queue.h	/^    vec<T>  buf;$/;"	m	class:Minisat::Queue
buffer_size	minisat/ParseUtils.h	/^    enum { buffer_size = 64*1024 };$/;"	e	enum:Minisat::StreamBuffer::__anon3
build	minisat/Heap.h	/^    void build(const vec<K>& ns) {$/;"	f	class:Minisat::Heap
buildTopoList	cir/cirNet.cpp	/^CirNet::buildTopoList()$/;"	f	class:CirNet
buildTopoListRec	cir/cirNet.cpp	/^CirNet::buildTopoListRec(CirGate* g)$/;"	f	class:CirNet
ca	minisat/Solver.cpp	/^    ClauseAllocator& ca;$/;"	m	struct:reduceDB_lt	file:
ca	minisat/Solver.h	/^        const ClauseAllocator& ca;$/;"	m	struct:Minisat::Solver::WatcherDeleted
ca	minisat/Solver.h	/^    ClauseAllocator     ca;$/;"	m	class:Minisat::Solver
ca	minisat/SolverTypes.h	/^    const ClauseAllocator& ca;$/;"	m	class:Minisat::ClauseIterator
calcAbstraction	minisat/SolverTypes.h	/^    void calcAbstraction() {$/;"	f	class:Minisat::Clause
cancelUntil	minisat/Solver.cpp	/^void Solver::cancelUntil(int level) {$/;"	f	class:Solver
cap	minisat/Alloc.h	/^    uint32_t  cap;$/;"	m	class:Minisat::RegionAllocator
cap	minisat/Map.h	/^    int        cap;$/;"	m	class:Minisat::Map
cap	minisat/Vec.h	/^    Size cap;$/;"	m	class:Minisat::vec
capacity	minisat/Alloc.h	/^void RegionAllocator<T>::capacity(uint32_t min_cap)$/;"	f	class:Minisat::RegionAllocator
capacity	minisat/Vec.h	/^    int      capacity (void) const   { return cap; }$/;"	f	class:Minisat::vec
capacity	minisat/Vec.h	/^void vec<T,_Size>::capacity(Size min_cap) {$/;"	f	class:Minisat::vec
category	minisat/Options.h	/^    const char* category;$/;"	m	class:Minisat::Option
ccmin_mode	minisat/Solver.h	/^    int       ccmin_mode;         \/\/ Controls conflict clause minimization (0=none, 1=basic, 2=deep).$/;"	m	class:Minisat::Solver
checkCap	minisat/Map.h	/^    bool    checkCap(int new_size) const { return new_size > cap; }$/;"	f	class:Minisat::Map
checkGarbage	minisat/Solver.h	/^inline void Solver::checkGarbage(double gf){$/;"	f	class:Minisat::Solver
checkGarbage	minisat/Solver.h	/^inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }$/;"	f	class:Minisat::Solver
checkMem	util/myUsage.h	/^   double checkMem() const {$/;"	f	class:MyUsage
checkTick	util/myUsage.h	/^   double checkTick() const {$/;"	f	class:MyUsage
claBumpActivity	minisat/Solver.h	/^inline void Solver::claBumpActivity (Clause& c) {$/;"	f	class:Minisat::Solver
claDecayActivity	minisat/Solver.h	/^inline void Solver::claDecayActivity() { cla_inc *= (1 \/ clause_decay); }$/;"	f	class:Minisat::Solver
cla_inc	minisat/Solver.h	/^    double              cla_inc;          \/\/ Amount to bump next clause with.$/;"	m	class:Minisat::Solver
clauseWord32Size	minisat/SolverTypes.h	/^    static uint32_t clauseWord32Size(int size, bool has_extra){$/;"	f	class:Minisat::ClauseAllocator
clause_decay	minisat/Solver.h	/^    double    clause_decay;$/;"	m	class:Minisat::Solver
clauses	minisat/Solver.h	/^    vec<CRef>           clauses;          \/\/ List of problem clauses.$/;"	m	class:Minisat::Solver
clausesBegin	minisat/Solver.h	/^inline ClauseIterator Solver::clausesBegin() const { return ClauseIterator(ca, &clauses[0]); }$/;"	f	class:Minisat::Solver
clausesEnd	minisat/Solver.h	/^inline ClauseIterator Solver::clausesEnd  () const { return ClauseIterator(ca, &clauses[clauses.size()]); }$/;"	f	class:Minisat::Solver
clauses_literals	minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
clean	minisat/SolverTypes.h	/^void OccLists<K,Vec,Deleted,MkIndex>::clean(const K& idx)$/;"	f	class:Minisat::OccLists
cleanAll	minisat/SolverTypes.h	/^void OccLists<K,Vec,Deleted,MkIndex>::cleanAll()$/;"	f	class:Minisat::OccLists
clear	minisat/Heap.h	/^    void clear(bool dispose = false) $/;"	f	class:Minisat::Heap
clear	minisat/IntMap.h	/^        void     clear       (bool free = false){$/;"	f	class:Minisat::IntSet
clear	minisat/IntMap.h	/^        void     clear  (bool dispose = false) { map.clear(dispose); }$/;"	f	class:Minisat::IntMap
clear	minisat/Map.h	/^    void clear  () {$/;"	f	class:Minisat::Map
clear	minisat/Queue.h	/^    void clear (bool dealloc = false) { buf.clear(dealloc); buf.growTo(1); first = end = 0; }$/;"	f	class:Minisat::Queue
clear	minisat/SolverTypes.h	/^    void     clear       ()                           { map.clear(); }$/;"	f	class:Minisat::CMap
clear	minisat/SolverTypes.h	/^    void  clear(bool free = true){$/;"	f	class:Minisat::OccLists
clear	minisat/Vec.h	/^void vec<T,_Size>::clear(bool dealloc) {$/;"	f	class:Minisat::vec
clearInterrupt	minisat/Solver.h	/^inline void     Solver::clearInterrupt(){ asynch_interrupt = false; }$/;"	f	class:Minisat::Solver
conflict	minisat/Solver.h	/^    LSet       conflict;          \/\/ If problem is unsatisfiable (possibly under assumptions),$/;"	m	class:Minisat::Solver
conflict_budget	minisat/Solver.h	/^    int64_t             conflict_budget;    \/\/ -1 means no budget.$/;"	m	class:Minisat::Solver
conflicts	minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
copy	minisat/Alg.h	/^static inline void copy(const T& from, T& to)$/;"	f	namespace:Minisat
copy	minisat/Alg.h	/^static inline void copy(const vec<T>& from, vec<T>& to, bool append = false)$/;"	f	namespace:Minisat
copyTo	minisat/IntMap.h	/^        void     copyTo (IntMap& to) const     { map.copyTo(to.map); to.index = index; }$/;"	f	class:Minisat::IntMap
copyTo	minisat/Vec.h	/^    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (Size i = 0; i < sz; i++) copy[i] = data[i]; }$/;"	f	class:Minisat::vec
cpuTime	minisat/System.h	/^static inline double Minisat::cpuTime(void) { return (double)clock() \/ CLOCKS_PER_SEC; }$/;"	f	class:Minisat
createGate	cir/cirNet.cpp	/^CirNet::createGate(const GateType& t, const string& name, unsigned id)$/;"	f	class:CirNet
cref	minisat/Solver.h	/^        CRef cref;$/;"	m	struct:Minisat::Solver::Watcher
crefs	minisat/SolverTypes.h	/^    const CRef*            crefs;$/;"	m	class:Minisat::ClauseIterator
data	minisat/Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Minisat::Map::Pair
data	minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	class:Minisat::Clause	typeref:union:Minisat::Clause::__anon5
data	minisat/Vec.h	/^    T*   data;$/;"	m	class:Minisat::vec
debug	minisat/SolverTypes.h	/^    void debug(){$/;"	f	class:Minisat::CMap
dec_vars	minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
decision	minisat/Solver.h	/^    VMap<char>          decision;         \/\/ Declares if a variable is eligible for selection in the decision heuristic.$/;"	m	class:Minisat::Solver
decisionLevel	minisat/Solver.h	/^inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }$/;"	f	class:Minisat::Solver
decisions	minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
decrease	minisat/Heap.h	/^    void decrease  (K k) { assert(inHeap(k)); percolateUp  (indices[k]); }$/;"	f	class:Minisat::Heap
deleted	minisat/SolverTypes.h	/^    Deleted                  deleted;$/;"	m	class:Minisat::OccLists
description	minisat/Options.h	/^    const char* description;$/;"	m	class:Minisat::Option
detachClause	minisat/Solver.cpp	/^void Solver::detachClause(CRef cr, bool strict){$/;"	f	class:Solver
dirties	minisat/SolverTypes.h	/^    vec<K>                   dirties;$/;"	m	class:Minisat::OccLists
dirty	minisat/SolverTypes.h	/^    IntMap<K, char, MkIndex> dirty;$/;"	m	class:Minisat::OccLists
drand	minisat/Rnd.h	/^static inline double drand(double& seed)$/;"	f	namespace:Minisat
drand	minisat/Solver.h	/^    static inline double drand(double& seed) {$/;"	f	class:Minisat::Solver
eagerMatch	minisat/ParseUtils.h	/^static bool eagerMatch(B& in, const char* str) {$/;"	f	namespace:Minisat
elems	minisat/Map.h	/^    int  elems() const { return size; }$/;"	f	class:Minisat::Map
empty	minisat/Heap.h	/^    bool empty     ()          const { return heap.size() == 0; }$/;"	f	class:Minisat::Heap
end	minisat/IntMap.h	/^        V*       end    ()       { return &map[map.size()]; }$/;"	f	class:Minisat::IntMap
end	minisat/IntMap.h	/^        const V* end    () const { return &map[map.size()]; }$/;"	f	class:Minisat::IntMap
end	minisat/Options.h	/^    double end;$/;"	m	struct:Minisat::DoubleRange
end	minisat/Options.h	/^    int end;$/;"	m	struct:Minisat::IntRange
end	minisat/Options.h	/^    int64_t end;$/;"	m	struct:Minisat::Int64Range
end	minisat/Queue.h	/^    int     end;$/;"	m	class:Minisat::Queue
end_inclusive	minisat/Options.h	/^    bool  end_inclusive;$/;"	m	struct:Minisat::DoubleRange
enqueue	minisat/Solver.h	/^inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, from), true); }$/;"	f	class:Minisat::Solver
equals	minisat/Map.h	/^    E          equals;$/;"	m	class:Minisat::Map
extra_clause_field	minisat/SolverTypes.h	/^    bool extra_clause_field;$/;"	m	class:Minisat::ClauseAllocator
find	minisat/Alg.h	/^static inline bool find(V& ts, const T& t)$/;"	f	namespace:Minisat
first	minisat/Queue.h	/^    int     first;$/;"	m	class:Minisat::Queue
flipInv	cir/cirGate.h	/^	void flipInv() { _gateV ^= (size_t)INV_MASK; }$/;"	f	class:CirGateV
free	minisat/Alloc.h	/^    void     free      (int size)    { wasted_ += size; }$/;"	f	class:Minisat::RegionAllocator
free	minisat/SolverTypes.h	/^    void free(CRef cid)$/;"	f	class:Minisat::ClauseAllocator
free_vars	minisat/Solver.h	/^    vec<Var>            free_vars;$/;"	m	class:Minisat::Solver
garbageCollect	minisat/Solver.cpp	/^void Solver::garbageCollect()$/;"	f	class:Solver
garbage_frac	minisat/Solver.h	/^    double    garbage_frac;       \/\/ The fraction of wasted memory allowed before a garbage collection is triggered.$/;"	m	class:Minisat::Solver
getF	cir/cirMgr.h	/^	CirNet* getF() { return _F; }$/;"	f	class:CirMgr
getFanin	cir/cirGate.h	/^	CirGate* getFanin(unsigned idx) 				{ return _in[idx].getGate(); }$/;"	f	class:CirGate
getFaninSize	cir/cirGate.h	/^	unsigned getFaninSize() 						{ return _in.size(); }$/;"	f	class:CirGate
getFanout	cir/cirGate.h	/^	CirGate* getFanout(unsigned idx) 				{ return _out[idx].getGate(); }$/;"	f	class:CirGate
getFanoutSize	cir/cirGate.h	/^	unsigned getFanoutSize() 						{ return _out.size(); }$/;"	f	class:CirGate
getG	cir/cirMgr.h	/^	CirNet* getG() { return _G; }$/;"	f	class:CirMgr
getGate	cir/cirGate.h	/^	CirGate* getGate() { return (CirGate*)(_gateV & ~(size_t)INV_MASK); }$/;"	f	class:CirGateV
getHelpPrefixString	minisat/Options.h	/^    static const char*&  getHelpPrefixString() { static const char* help_prefix_str = ""; return help_prefix_str; }$/;"	f	class:Minisat::Option
getId	cir/cirGate.h	/^	unsigned getId() 				{ return _id; }$/;"	f	class:CirGate
getName	cir/cirGate.h	/^	const string& getName() 		{ return _name; }$/;"	f	class:CirGate
getOptionList	minisat/Options.h	/^    static vec<Option*>& getOptionList () { static vec<Option*> options; return options; }$/;"	f	class:Minisat::Option
getPath	cir/cirMgr.h	/^	CirNet* getPath() { return _patch; }$/;"	f	class:CirMgr
getType	cir/cirGate.cpp	/^CirAndGate::getType() const$/;"	f	class:CirAndGate
getType	cir/cirGate.cpp	/^CirBufGate::getType() const$/;"	f	class:CirBufGate
getType	cir/cirGate.cpp	/^CirConstGate::getType() const$/;"	f	class:CirConstGate
getType	cir/cirGate.cpp	/^CirErrorGate::getType() const$/;"	f	class:CirErrorGate
getType	cir/cirGate.cpp	/^CirInvGate::getType() const$/;"	f	class:CirInvGate
getType	cir/cirGate.cpp	/^CirNandGate::getType() const$/;"	f	class:CirNandGate
getType	cir/cirGate.cpp	/^CirNorGate::getType() const$/;"	f	class:CirNorGate
getType	cir/cirGate.cpp	/^CirOrGate::getType() const$/;"	f	class:CirOrGate
getType	cir/cirGate.cpp	/^CirPiGate::getType() const$/;"	f	class:CirPiGate
getType	cir/cirGate.cpp	/^CirPoGate::getType() const$/;"	f	class:CirPoGate
getType	cir/cirGate.cpp	/^CirXnorGate::getType() const$/;"	f	class:CirXnorGate
getType	cir/cirGate.cpp	/^CirXorGate::getType() const$/;"	f	class:CirXorGate
getUsageString	minisat/Options.h	/^    static const char*&  getUsageString() { static const char* usage_str; return usage_str; }$/;"	f	class:Minisat::Option
getVal	minisat/sat.h	/^  unsigned getVal(Var var) const {$/;"	f	class:SatSolver
getVal	util/unate.h	/^  unsigned getVal() const { return val_; }$/;"	f	class:Unateness
growTo	minisat/SolverTypes.h	/^    void     growTo      (CRef cr, const T& t){ map.insert(cr, t); } \/\/ NOTE: for compatibility$/;"	f	class:Minisat::CMap
growTo	minisat/Vec.h	/^void vec<T,_Size>::growTo(Size size) {$/;"	f	class:Minisat::vec
growTo	minisat/Vec.h	/^void vec<T,_Size>::growTo(Size size, const T& pad) {$/;"	f	class:Minisat::vec
has	minisat/IntMap.h	/^        bool     has         (K k) { in_set.reserve(k, 0); return in_set[k]; }$/;"	f	class:Minisat::IntSet
has	minisat/IntMap.h	/^        bool     has       (K k) const { return index(k) < map.size(); }$/;"	f	class:Minisat::IntMap
has	minisat/Map.h	/^    bool has   (const K& k) const {$/;"	f	class:Minisat::Map
has	minisat/SolverTypes.h	/^    bool     has         (CRef cr, T& t)      { return map.peek(cr, t); }$/;"	f	class:Minisat::CMap
has_extra	minisat/SolverTypes.h	/^        unsigned has_extra : 1;$/;"	m	struct:Minisat::Clause::__anon4
has_extra	minisat/SolverTypes.h	/^    bool         has_extra   ()      const   { return header.has_extra; }$/;"	f	class:Minisat::Clause
hash	minisat/Map.h	/^    H          hash;$/;"	m	class:Minisat::Map
hash	minisat/Map.h	/^static inline uint32_t hash(int32_t x) { return (uint32_t)x; }$/;"	f	namespace:Minisat
hash	minisat/Map.h	/^static inline uint32_t hash(int64_t x) { return (uint32_t)x; }$/;"	f	namespace:Minisat
hash	minisat/Map.h	/^static inline uint32_t hash(uint32_t x){ return x; }$/;"	f	namespace:Minisat
hash	minisat/Map.h	/^static inline uint32_t hash(uint64_t x){ return (uint32_t)x; }$/;"	f	namespace:Minisat
header	minisat/SolverTypes.h	/^        unsigned size      : 27; }                        header;$/;"	m	class:Minisat::Clause	typeref:struct:Minisat::Clause::__anon4
heap	minisat/Heap.h	/^    vec<K>                heap;     \/\/ Heap of Keys$/;"	m	class:Minisat::Heap
help	minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::BoolOption
help	minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::DoubleOption
help	minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::Int64Option
help	minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::IntOption
help	minisat/Options.h	/^    virtual void help (bool verbose = false){$/;"	f	class:Minisat::StringOption
i	minisat/Solver.h	/^        uint32_t i;$/;"	m	struct:Minisat::Solver::ShrinkStackElem
implies	minisat/Solver.cpp	/^bool Solver::implies(const vec<Lit>& assumps, vec<Lit>& out)$/;"	f	class:Solver
in	minisat/ParseUtils.h	/^    gzFile         in;$/;"	m	class:Minisat::StreamBuffer
inHeap	minisat/Heap.h	/^    bool inHeap    (K k)       const { return indices.has(k) && indices[k] >= 0; }$/;"	f	class:Minisat::Heap
in_set	minisat/IntMap.h	/^        IntMap<K, char, MkIndex> in_set;$/;"	m	class:Minisat::IntSet
incRef	cir/cirGate.h	/^	static void incRef() 	{ ++_globalRef; }$/;"	f	class:CirGate
increase	minisat/Heap.h	/^    void increase  (K k) { assert(inHeap(k)); percolateDown(indices[k]); }$/;"	f	class:Minisat::Heap
index	minisat/IntMap.h	/^        MkIndex  index;$/;"	m	class:Minisat::IntMap
index	minisat/Map.h	/^    int32_t index  (const K& k) const { return hash(k) % cap; }$/;"	f	class:Minisat::Map
indices	minisat/Heap.h	/^    IntMap<K,int,MkIndex> indices;  \/\/ Each Key's position (index) in the Heap$/;"	m	class:Minisat::Heap
init	cir/cirNet.cpp	/^CirNet::init()$/;"	f	class:CirNet
init	minisat/SolverTypes.h	/^    void  init      (const K& idx){ occs.reserve(idx); occs[idx].clear(); dirty.reserve(idx, 0); }$/;"	f	class:Minisat::OccLists
init	minisat/sat.h	/^  void init() {$/;"	f	class:SatSolver
insert	minisat/Heap.h	/^    void insert(K k)$/;"	f	class:Minisat::Heap
insert	minisat/IntMap.h	/^        void     insert      (K k) { in_set.reserve(k, 0); if (!in_set[k]) { in_set[k] = 1; xs.push(k); } }$/;"	f	class:Minisat::IntSet
insert	minisat/IntMap.h	/^        void     insert (K key, V val)       { reserve(key); operator[](key) = val; }$/;"	f	class:Minisat::IntMap
insert	minisat/IntMap.h	/^        void     insert (K key, V val, V pad){ reserve(key, pad); operator[](key) = val; }$/;"	f	class:Minisat::IntMap
insert	minisat/Map.h	/^    void insert (const K& k, const D& d) { if (checkCap(size+1)) rehash(); _insert(k, d); size++; }$/;"	f	class:Minisat::Map
insert	minisat/Queue.h	/^    void insert(T elem) {   \/\/ INVARIANT: buf[end] is always unused$/;"	f	class:Minisat::Queue
insert	minisat/SolverTypes.h	/^    void     insert      (CRef cr, const T& t){ map.insert(cr, t); }$/;"	f	class:Minisat::CMap
insertVarOrder	minisat/Solver.h	/^inline void Solver::insertVarOrder(Var x) {$/;"	f	class:Minisat::Solver
interrupt	minisat/Solver.h	/^inline void     Solver::interrupt(){ asynch_interrupt = true; }$/;"	f	class:Minisat::Solver
irand	minisat/Rnd.h	/^static inline int irand(double& seed, int size) { return (int)(drand(seed) * size); }$/;"	f	namespace:Minisat
irand	minisat/Solver.h	/^    static inline int irand(double& seed, int size) {$/;"	f	class:Minisat::Solver
isBinate	util/unate.h	/^  bool isBinate() const { return val_ == 3; }$/;"	f	class:Unateness
isEof	minisat/ParseUtils.h	/^static inline bool isEof(StreamBuffer& in) { return *in == EOF;  }$/;"	f	namespace:Minisat
isEof	minisat/ParseUtils.h	/^static inline bool isEof(const char*   in) { return *in == '\\0'; }$/;"	f	namespace:Minisat
isInv	cir/cirGate.h	/^	bool isInv() const { return _gateV & (size_t)INV_MASK; }$/;"	f	class:CirGateV
isNeg	util/unate.h	/^  bool isNeg()    const { return val_ == 2; }$/;"	f	class:Unateness
isNull	util/unate.h	/^  bool isNull()   const { return val_ == 0; }$/;"	f	class:Unateness
isPos	util/unate.h	/^  bool isPos()    const { return val_ == 1; }$/;"	f	class:Unateness
isRef	cir/cirGate.h	/^	bool isRef() 			{ return _ref == _globalRef; }$/;"	f	class:CirGate
isRemoved	minisat/Solver.h	/^inline bool     Solver::isRemoved       (CRef cr)         const { return ca[cr].mark() == 1; }$/;"	f	class:Minisat::Solver
isUnate	util/unate.h	/^  bool isUnate()  const { return isPos() || isNeg(); }$/;"	f	class:Unateness
key	minisat/Map.h	/^    struct Pair { K key; D data; };$/;"	m	struct:Minisat::Map::Pair
l	minisat/Solver.h	/^        Lit      l;$/;"	m	struct:Minisat::Solver::ShrinkStackElem
l_False	minisat/SolverTypes.h	126;"	d
l_True	minisat/SolverTypes.h	125;"	d
l_Undef	minisat/SolverTypes.h	127;"	d
last	minisat/SolverTypes.h	/^    const Lit&   last        ()      const   { return data[header.size-1].lit; }$/;"	f	class:Minisat::Clause
last	minisat/Vec.h	/^    T&       last  (void)              { return data[sz-1]; }$/;"	f	class:Minisat::vec
last	minisat/Vec.h	/^    const T& last  (void) const        { return data[sz-1]; }$/;"	f	class:Minisat::vec
lbool	minisat/SolverTypes.h	/^    explicit lbool(bool x) : value(!x) { }$/;"	f	class:Minisat::lbool
lbool	minisat/SolverTypes.h	/^    explicit lbool(uint8_t v) : value(v) { }$/;"	f	class:Minisat::lbool
lbool	minisat/SolverTypes.h	/^    lbool()       : value(0) { }$/;"	f	class:Minisat::lbool
lbool	minisat/SolverTypes.h	/^class lbool {$/;"	c	namespace:Minisat
lea	minisat/Alloc.h	/^    T*       lea       (Ref r)       { assert(r < sz); return &memory[r]; }$/;"	f	class:Minisat::RegionAllocator
lea	minisat/Alloc.h	/^    const T* lea       (Ref r) const { assert(r < sz); return &memory[r]; }$/;"	f	class:Minisat::RegionAllocator
lea	minisat/SolverTypes.h	/^    Clause*       lea       (CRef r)         { return (Clause*)ra.lea(r); }$/;"	f	class:Minisat::ClauseAllocator
lea	minisat/SolverTypes.h	/^    const Clause* lea       (CRef r) const   { return (Clause*)ra.lea(r);; }$/;"	f	class:Minisat::ClauseAllocator
learnt	minisat/SolverTypes.h	/^        unsigned learnt    : 1;$/;"	m	struct:Minisat::Clause::__anon4
learnt	minisat/SolverTypes.h	/^    bool         learnt      ()      const   { return header.learnt; }$/;"	f	class:Minisat::Clause
learnts	minisat/Solver.h	/^    vec<CRef>           learnts;          \/\/ List of learnt clauses.$/;"	m	class:Minisat::Solver
learnts_literals	minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
learntsize_adjust_cnt	minisat/Solver.h	/^    int                 learntsize_adjust_cnt;$/;"	m	class:Minisat::Solver
learntsize_adjust_confl	minisat/Solver.h	/^    double              learntsize_adjust_confl;$/;"	m	class:Minisat::Solver
learntsize_adjust_inc	minisat/Solver.h	/^    double    learntsize_adjust_inc;$/;"	m	class:Minisat::Solver
learntsize_adjust_start_confl	minisat/Solver.h	/^    int       learntsize_adjust_start_confl;$/;"	m	class:Minisat::Solver
learntsize_factor	minisat/Solver.h	/^    double    learntsize_factor;  \/\/ The intitial limit for learnt clauses is a factor of the original clauses.                (default 1 \/ 3)$/;"	m	class:Minisat::Solver
learntsize_inc	minisat/Solver.h	/^    double    learntsize_inc;     \/\/ The limit for learnt clauses is multiplied with this factor each restart.                 (default 1.1)$/;"	m	class:Minisat::Solver
left	minisat/Heap.h	/^    static inline int left  (int i) { return i*2+1; }$/;"	f	class:Minisat::Heap
level	minisat/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	m	struct:Minisat::Solver::VarData
level	minisat/Solver.h	/^inline int  Solver::level (Var x) const { return vardata[x].level; }$/;"	f	class:Minisat::Solver
limitMemory	minisat/System.cpp	/^void Minisat::limitMemory(uint64_t \/*max_mem_mb*\/)$/;"	f	class:Minisat
limitMemory	minisat/System.cpp	/^void Minisat::limitMemory(uint64_t max_mem_mb)$/;"	f	class:Minisat
limitTime	minisat/System.cpp	/^void Minisat::limitTime(uint32_t \/*max_cpu_time*\/)$/;"	f	class:Minisat
limitTime	minisat/System.cpp	/^void Minisat::limitTime(uint32_t max_cpu_time)$/;"	f	class:Minisat
lit	minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon5
litRedundant	minisat/Solver.cpp	/^bool Solver::litRedundant(Lit p)$/;"	f	class:Solver
lit_Error	minisat/SolverTypes.h	/^const Lit lit_Error = { -1 };  \/\/ }$/;"	m	namespace:Minisat
lit_Undef	minisat/SolverTypes.h	/^const Lit lit_Undef = { -2 };  \/\/ }- Useful special constants.$/;"	m	namespace:Minisat
lits	minisat/SolverTypes.h	/^    const Lit* lits;$/;"	m	class:Minisat::TrailIterator
locked	minisat/Solver.h	/^inline bool     Solver::locked          (const Clause& c) const { return value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c; }$/;"	f	class:Minisat::Solver
lookup	minisat/SolverTypes.h	/^    Vec&  lookup    (const K& idx){ if (dirty[idx]) clean(idx); return occs[idx]; }$/;"	f	class:Minisat::OccLists
lt	minisat/Heap.h	/^    Comp                  lt;       \/\/ The heap is a minimum-heap with respect to this comparator$/;"	m	class:Minisat::Heap
luby	minisat/Solver.cpp	/^static double luby(double y, int x){$/;"	f	file:
luby_restart	minisat/Solver.h	/^    bool      luby_restart;$/;"	m	class:Minisat::Solver
main	main/main.cpp	/^int main(int argc, char** argv) {$/;"	f
map	minisat/IntMap.h	/^        vec<V>   map;$/;"	m	class:Minisat::IntMap
map	minisat/SolverTypes.h	/^    HashTable map;$/;"	m	class:Minisat::CMap
mapVar	minisat/Solver.cpp	/^static Var mapVar(Var x, vec<Var>& map, Var& max)$/;"	f	file:
mark	minisat/SolverTypes.h	/^        unsigned mark      : 2;$/;"	m	struct:Minisat::Clause::__anon4
mark	minisat/SolverTypes.h	/^    uint32_t     mark        ()      const   { return header.mark; }$/;"	f	class:Minisat::Clause
mark	minisat/SolverTypes.h	/^    void         mark        (uint32_t m)    { header.mark = m; }$/;"	f	class:Minisat::Clause
match	minisat/ParseUtils.h	/^static bool match(B& in, const char* str) {$/;"	f	namespace:Minisat
max	minisat/Vec.h	/^    static inline Size max(Size x, Size y){ return (x > y) ? x : y; }$/;"	f	class:Minisat::vec
max_learnts	minisat/Solver.h	/^    double              max_learnts;$/;"	m	class:Minisat::Solver
max_literals	minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
memReadPeak	minisat/System.cpp	/^static inline int memReadPeak(void)$/;"	f	file:
memReadStat	minisat/System.cpp	/^static inline int memReadStat(int field)$/;"	f	file:
memUsed	minisat/System.cpp	/^double Minisat::memUsed()     { return 0; }$/;"	f	class:Minisat
memUsed	minisat/System.cpp	/^double Minisat::memUsed() { return (double)memReadStat(0) * (double)getpagesize() \/ (1024*1024); }$/;"	f	class:Minisat
memUsed	minisat/System.cpp	/^double Minisat::memUsed() {$/;"	f	class:Minisat
memUsedPeak	minisat/System.cpp	/^double Minisat::memUsedPeak() { return 0; }$/;"	f	class:Minisat
memUsedPeak	minisat/System.cpp	/^double Minisat::memUsedPeak() { return memUsed(); }$/;"	f	class:Minisat
memUsedPeak	minisat/System.cpp	/^double Minisat::memUsedPeak(bool strictlyPeak) { $/;"	f	class:Minisat
memory	minisat/Alloc.h	/^    T*        memory;$/;"	m	class:Minisat::RegionAllocator
min_learnts_lim	minisat/Solver.h	/^    int       min_learnts_lim;    \/\/ Minimum number to set the learnts limit to.$/;"	m	class:Minisat::Solver
mkLit	minisat/SolverTypes.h	/^inline  Lit  mkLit     (Var var, bool sign) { Lit p; p.x = var + var + (int)sign; return p; }$/;"	f	namespace:Minisat
mkVarData	minisat/Solver.h	/^    static inline VarData mkVarData(CRef cr, int l){ VarData d = {cr, l}; return d; }$/;"	f	class:Minisat::Solver
model	minisat/Solver.h	/^    vec<lbool> model;             \/\/ If problem is satisfiable, this vector contains the model (if any).$/;"	m	class:Minisat::Solver
modelValue	minisat/Solver.h	/^inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }$/;"	f	class:Minisat::Solver
modelValue	minisat/Solver.h	/^inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }$/;"	f	class:Minisat::Solver
moveTo	minisat/Alloc.h	/^    void     moveTo(RegionAllocator& to) {$/;"	f	class:Minisat::RegionAllocator
moveTo	minisat/IntMap.h	/^        void     moveTo (IntMap& to)           { map.moveTo(to.map); to.index = index; }$/;"	f	class:Minisat::IntMap
moveTo	minisat/Map.h	/^    void moveTo(Map& other){$/;"	f	class:Minisat::Map
moveTo	minisat/SolverTypes.h	/^    void moveTo(CMap& other){ map.moveTo(other.map); }$/;"	f	class:Minisat::CMap
moveTo	minisat/SolverTypes.h	/^    void moveTo(ClauseAllocator& to){$/;"	f	class:Minisat::ClauseAllocator
moveTo	minisat/Vec.h	/^    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }$/;"	f	class:Minisat::vec
mySplit	util/myString.h	/^std::vector<std::string> mySplit(const std::string& str) {$/;"	f
myToString	util/parse.h	/^std::string myToString(unsigned n) {$/;"	f
nAssigns	minisat/Solver.h	/^inline int      Solver::nAssigns      ()      const   { return trail.size(); }$/;"	f	class:Minisat::Solver
nClauses	minisat/Solver.h	/^inline int      Solver::nClauses      ()      const   { return num_clauses; }$/;"	f	class:Minisat::Solver
nFreeVars	minisat/Solver.h	/^inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }$/;"	f	class:Minisat::Solver
nLearnts	minisat/Solver.h	/^inline int      Solver::nLearnts      ()      const   { return num_learnts; }$/;"	f	class:Minisat::Solver
nVars	minisat/Solver.h	/^inline int      Solver::nVars         ()      const   { return next_var; }$/;"	f	class:Minisat::Solver
nVars	minisat/sat.h	/^  int nVars() const { return solver_->nVars(); }$/;"	f	class:SatSolver
name	minisat/Options.h	/^    const char* name;$/;"	m	class:Minisat::Option
newDecisionLevel	minisat/Solver.h	/^inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }$/;"	f	class:Minisat::Solver
newVar	minisat/Solver.cpp	/^Var Solver::newVar(lbool upol, bool dvar)$/;"	f	class:Solver
newVar	minisat/sat.h	/^  Var newVar() { return solver_->newVar(); }$/;"	f	class:SatSolver
next_var	minisat/Solver.h	/^    Var                 next_var;         \/\/ Next variable to be created.$/;"	m	class:Minisat::Solver
nprimes	minisat/Map.h	/^static const int nprimes          = 25;$/;"	m	namespace:Minisat
num_clauses	minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
num_learnts	minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
occs	minisat/SolverTypes.h	/^    IntMap<K, Vec,  MkIndex> occs;$/;"	m	class:Minisat::OccLists
ok	minisat/Solver.h	/^    bool                ok;               \/\/ If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!$/;"	m	class:Minisat::Solver
okay	minisat/Solver.h	/^inline bool     Solver::okay          ()      const   { return ok; }$/;"	f	class:Minisat::Solver
operator !	minisat/SolverTypes.h	/^    lbool operator !  ()        const { return lbool((uint8_t)(value^(uint8_t)1)); } \/\/ added by music960633$/;"	f	class:Minisat::lbool
operator !	util/bool3v.h	/^  bool_3v operator !() const {$/;"	f	class:bool_3v
operator !=	minisat/Solver.h	/^        bool operator!=(const Watcher& w) const { return cref != w.cref; }$/;"	f	struct:Minisat::Solver::Watcher
operator !=	minisat/SolverTypes.h	/^    bool  operator != (lbool b) const { return !(*this == b); }$/;"	f	class:Minisat::lbool
operator !=	minisat/SolverTypes.h	/^    bool operator != (Lit p) const { return x != p.x; }$/;"	f	struct:Minisat::Lit
operator !=	minisat/SolverTypes.h	/^    bool operator!=(const ClauseIterator& ci) const { return crefs != ci.crefs; }$/;"	f	class:Minisat::ClauseIterator
operator !=	minisat/SolverTypes.h	/^    bool operator!=(const TrailIterator& ti) const { return lits != ti.lits; }$/;"	f	class:Minisat::TrailIterator
operator !=	util/bool3v.h	/^  bool operator != (bool_3v b) const { return !(*this == b); }$/;"	f	class:bool_3v
operator !=	util/unate.h	/^  bool operator != (const Unateness& u) const { return val_ != u.val_; }$/;"	f	class:Unateness
operator &&	minisat/SolverTypes.h	/^    lbool operator && (lbool b) const { $/;"	f	class:Minisat::lbool
operator &&	util/bool3v.h	/^  bool_3v operator && (bool_3v b) const {$/;"	f	class:bool_3v
operator ()	minisat/IntMap.h	/^        typename vec<T>::Size operator()(T t) const { return (typename vec<T>::Size)t; }$/;"	f	struct:Minisat::MkIndexDefault
operator ()	minisat/Map.h	/^template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };$/;"	f	struct:Minisat::DeepEqual
operator ()	minisat/Map.h	/^template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };$/;"	f	struct:Minisat::DeepHash
operator ()	minisat/Map.h	/^template<class K> struct Equal { bool     operator()(const K& k1, const K& k2) const { return k1 == k2; } };$/;"	f	struct:Minisat::Equal
operator ()	minisat/Map.h	/^template<class K> struct Hash  { uint32_t operator()(const K& k)               const { return hash(k);  } };$/;"	f	struct:Minisat::Hash
operator ()	minisat/Options.h	/^        bool operator()(const Option* x, const Option* y) {$/;"	f	struct:Minisat::Option::OptionLt
operator ()	minisat/Solver.cpp	/^    bool operator () (CRef x, CRef y) { $/;"	f	struct:reduceDB_lt
operator ()	minisat/Solver.h	/^        bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }$/;"	f	struct:Minisat::Solver::VarOrderLt
operator ()	minisat/Solver.h	/^        bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }$/;"	f	struct:Minisat::Solver::WatcherDeleted
operator ()	minisat/SolverTypes.h	/^        uint32_t operator()(CRef cr) const { return (uint32_t)cr; } };$/;"	f	struct:Minisat::CMap::CRefHash
operator ()	minisat/SolverTypes.h	/^struct MkIndexLit { vec<Lit>::Size operator()(Lit l) const { return vec<Lit>::Size(l.x); } };$/;"	f	struct:Minisat::MkIndexLit
operator ()	minisat/Sort.h	/^    bool operator () (T x, T y) { return x < y; }$/;"	f	struct:Minisat::LessThan_default
operator *	minisat/ParseUtils.h	/^    int  operator *  () const { return (pos >= size) ? EOF : buf[pos]; }$/;"	f	class:Minisat::StreamBuffer
operator *	minisat/SolverTypes.h	/^    Lit  operator*() const { return *lits; }$/;"	f	class:Minisat::TrailIterator
operator *	minisat/SolverTypes.h	/^    const Clause& operator*() const { return ca[*crefs]; }$/;"	f	class:Minisat::ClauseIterator
operator ++	minisat/ParseUtils.h	/^    void operator ++ ()       { pos++; assureLookahead(); }$/;"	f	class:Minisat::StreamBuffer
operator ++	minisat/SolverTypes.h	/^    void operator++()   { lits++; }$/;"	f	class:Minisat::TrailIterator
operator ++	minisat/SolverTypes.h	/^    void operator++(){ crefs++; }$/;"	f	class:Minisat::ClauseIterator
operator <	minisat/SolverTypes.h	/^    bool operator <  (Lit p) const { return x < p.x;  } \/\/ '<' makes p, ~p adjacent in the ordering.$/;"	f	struct:Minisat::Lit
operator =	minisat/Options.h	/^    BoolOption& operator=(bool b)     { value = b; return *this; }$/;"	f	class:Minisat::BoolOption
operator =	minisat/Options.h	/^    DoubleOption& operator=(double x)   { value = x; return *this; }$/;"	f	class:Minisat::DoubleOption
operator =	minisat/Options.h	/^    Int64Option& operator= (int64_t x)  { value = x; return *this; }$/;"	f	class:Minisat::Int64Option
operator =	minisat/Options.h	/^    IntOption& operator= (int32_t x)  { value = x; return *this; }$/;"	f	class:Minisat::IntOption
operator =	minisat/Options.h	/^    StringOption& operator=    (const char* x)  { value = x; return *this; }$/;"	f	class:Minisat::StringOption
operator =	util/unate.h	/^  Unateness& operator = (const Unateness& u) { val_ = u.val_; return (*this); }$/;"	f	class:Unateness
operator ==	minisat/Solver.h	/^        bool operator==(const Watcher& w) const { return cref == w.cref; }$/;"	f	struct:Minisat::Solver::Watcher
operator ==	minisat/SolverTypes.h	/^    bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }$/;"	f	class:Minisat::lbool
operator ==	minisat/SolverTypes.h	/^    bool operator == (Lit p) const { return x == p.x; }$/;"	f	struct:Minisat::Lit
operator ==	minisat/SolverTypes.h	/^    bool operator==(const ClauseIterator& ci) const { return crefs == ci.crefs; }$/;"	f	class:Minisat::ClauseIterator
operator ==	minisat/SolverTypes.h	/^    bool operator==(const TrailIterator& ti) const { return lits == ti.lits; }$/;"	f	class:Minisat::TrailIterator
operator ==	util/bool3v.h	/^  bool operator == (bool_3v b) const {$/;"	f	class:bool_3v
operator ==	util/unate.h	/^  bool operator == (const Unateness& u) const { return val_ == u.val_; }$/;"	f	class:Unateness
operator T*	minisat/Vec.h	/^    operator T*       (void)           { return data; }$/;"	f	class:Minisat::vec
operator []	minisat/Alloc.h	/^    T&       operator[](Ref r)       { assert(r < sz); return memory[r]; }$/;"	f	class:Minisat::RegionAllocator
operator []	minisat/Alloc.h	/^    const T& operator[](Ref r) const { assert(r < sz); return memory[r]; }$/;"	f	class:Minisat::RegionAllocator
operator []	minisat/Heap.h	/^    int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }$/;"	f	class:Minisat::Heap
operator []	minisat/IntMap.h	/^        K        operator [] (int index) const  { return xs[index]; }$/;"	f	class:Minisat::IntSet
operator []	minisat/IntMap.h	/^        V&       operator[](K k)       { assert(has(k)); return map[index(k)]; }$/;"	f	class:Minisat::IntMap
operator []	minisat/IntMap.h	/^        const V& operator[](K k) const { assert(has(k)); return map[index(k)]; }$/;"	f	class:Minisat::IntMap
operator []	minisat/Map.h	/^    D& operator [] (const K& k)$/;"	f	class:Minisat::Map
operator []	minisat/Map.h	/^    const D& operator [] (const K& k) const$/;"	f	class:Minisat::Map
operator []	minisat/Queue.h	/^    T&       operator [] (int index)        { assert(index >= 0); assert(index < size()); return buf[(first + index) % buf.size()]; }$/;"	f	class:Minisat::Queue
operator []	minisat/Queue.h	/^    const T& operator [] (int index) const  { assert(index >= 0); assert(index < size()); return buf[(first + index) % buf.size()]; }$/;"	f	class:Minisat::Queue
operator []	minisat/SolverTypes.h	/^    Clause&       operator[](CRef r)         { return (Clause&)ra[r]; }$/;"	f	class:Minisat::ClauseAllocator
operator []	minisat/SolverTypes.h	/^    Lit          operator [] (int i) const   { return data[i].lit; }$/;"	f	class:Minisat::Clause
operator []	minisat/SolverTypes.h	/^    Lit&         operator [] (int i)         { return data[i].lit; }$/;"	f	class:Minisat::Clause
operator []	minisat/SolverTypes.h	/^    T&       operator [] (CRef cr)            { return map[cr]; }$/;"	f	class:Minisat::CMap
operator []	minisat/SolverTypes.h	/^    Vec&  operator[](const K& idx){ return occs[idx]; }$/;"	f	class:Minisat::OccLists
operator []	minisat/SolverTypes.h	/^    const Clause& operator[](CRef r) const   { return (Clause&)ra[r]; }$/;"	f	class:Minisat::ClauseAllocator
operator []	minisat/SolverTypes.h	/^    const T& operator [] (CRef cr) const      { return map[cr]; }$/;"	f	class:Minisat::CMap
operator []	minisat/Vec.h	/^    T&       operator [] (Size index)       { return data[index]; }$/;"	f	class:Minisat::vec
operator []	minisat/Vec.h	/^    const T& operator [] (Size index) const { return data[index]; }$/;"	f	class:Minisat::vec
operator ^	minisat/SolverTypes.h	/^    lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }$/;"	f	class:Minisat::lbool
operator ^	minisat/SolverTypes.h	/^inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }$/;"	f	namespace:Minisat
operator ^	util/bool3v.h	/^  bool_3v operator ^ (bool_3v b) const {$/;"	f	class:bool_3v
operator bool	minisat/Options.h	/^    operator    bool     (void) const { return value; }$/;"	f	class:Minisat::BoolOption
operator bool&	minisat/Options.h	/^    operator    bool&    (void)       { return value; }$/;"	f	class:Minisat::BoolOption
operator const Lit*	minisat/SolverTypes.h	/^    operator const Lit* (void) const         { return (Lit*)data; }$/;"	f	class:Minisat::Clause
operator const char*	minisat/Options.h	/^    operator      const char*  (void) const     { return value; }$/;"	f	class:Minisat::StringOption
operator const char*&	minisat/Options.h	/^    operator      const char*& (void)           { return value; }$/;"	f	class:Minisat::StringOption
operator double	minisat/Options.h	/^    operator      double   (void) const { return value; }$/;"	f	class:Minisat::DoubleOption
operator double&	minisat/Options.h	/^    operator      double&  (void)       { return value; }$/;"	f	class:Minisat::DoubleOption
operator int32_t	minisat/Options.h	/^    operator   int32_t   (void) const { return value; }$/;"	f	class:Minisat::IntOption
operator int32_t&	minisat/Options.h	/^    operator   int32_t&  (void)       { return value; }$/;"	f	class:Minisat::IntOption
operator int64_t	minisat/Options.h	/^    operator     int64_t   (void) const { return value; }$/;"	f	class:Minisat::Int64Option
operator int64_t&	minisat/Options.h	/^    operator     int64_t&  (void)       { return value; }$/;"	f	class:Minisat::Int64Option
operator |	util/unate.h	/^  Unateness operator | (Unateness u) { return Unateness(val_ | u.val_); }$/;"	f	class:Unateness
operator ||	minisat/SolverTypes.h	/^    lbool operator || (lbool b) const {$/;"	f	class:Minisat::lbool
operator ||	util/bool3v.h	/^  bool_3v operator || (bool_3v b) const {$/;"	f	class:bool_3v
operator ~	minisat/SolverTypes.h	/^inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }$/;"	f	namespace:Minisat
operator ~	util/unate.h	/^  Unateness operator ~() { return Unateness((0xd8 >> (val_ << 1)) & 3); }$/;"	f	class:Unateness
order_heap	minisat/Solver.h	/^    Heap<Var,VarOrderLt>order_heap;       \/\/ A priority queue of variables ordered with respect to the variable activity.$/;"	m	class:Minisat::Solver
parent	minisat/Heap.h	/^    static inline int parent(int i) { return (i-1) >> 1; }$/;"	f	class:Minisat::Heap
parse	cir/cirParse.cpp	/^bool CirNet::parse(const std::string& filename) {$/;"	f	class:CirNet
parse	minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::BoolOption
parse	minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::DoubleOption
parse	minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::Int64Option
parse	minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::IntOption
parse	minisat/Options.h	/^    virtual bool parse(const char* str){$/;"	f	class:Minisat::StringOption
parseInt	minisat/ParseUtils.h	/^static int parseInt(B& in) {$/;"	f	namespace:Minisat
parseOptions	minisat/Options.cpp	/^void Minisat::parseOptions(int& argc, char** argv, bool strict)$/;"	f	class:Minisat
peek	minisat/Map.h	/^    bool peek   (const K& k, D& d) const {$/;"	f	class:Minisat::Map
peek	minisat/Queue.h	/^    T    peek  () const { assert(first != end); return buf[first]; }$/;"	f	class:Minisat::Queue
percolateDown	minisat/Heap.h	/^    void percolateDown(int i)$/;"	f	class:Minisat::Heap
percolateUp	minisat/Heap.h	/^    void percolateUp(int i)$/;"	f	class:Minisat::Heap
phase_saving	minisat/Solver.h	/^    int       phase_saving;       \/\/ Controls the level of phase saving (0=none, 1=limited, 2=full).$/;"	m	class:Minisat::Solver
pickBranchLit	minisat/Solver.cpp	/^Lit Solver::pickBranchLit()$/;"	f	class:Solver
polarity	minisat/Solver.h	/^    VMap<char>          polarity;         \/\/ The preferred polarity of each variable.$/;"	m	class:Minisat::Solver
pop	minisat/Queue.h	/^    void pop   () { assert(first != end); first++; if (first == buf.size()) first = 0; }$/;"	f	class:Minisat::Queue
pop	minisat/SolverTypes.h	/^    void         pop         ()              { shrink(1); }$/;"	f	class:Minisat::Clause
pop	minisat/Vec.h	/^    void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }$/;"	f	class:Minisat::vec
pos	minisat/ParseUtils.h	/^    int            pos;$/;"	m	class:Minisat::StreamBuffer
position	minisat/ParseUtils.h	/^    int  position    () const { return pos; }$/;"	f	class:Minisat::StreamBuffer
primes	minisat/Map.h	/^static const int primes [nprimes] = { 31, 73, 151, 313, 643, 1291, 2593, 5233, 10501, 21013, 42073, 84181, 168451, 337219, 674701, 1349473, 2699299, 5398891, 10798093, 21596719, 43193641, 86387383, 172775299, 345550609, 691101253 };$/;"	m	namespace:Minisat
printStats	minisat/Solver.cpp	/^void Solver::printStats() const$/;"	f	class:Solver
printUsageAndExit	minisat/Options.cpp	/^void Minisat::printUsageAndExit (int \/*argc*\/, char** argv, bool verbose)$/;"	f	class:Minisat
progressEstimate	minisat/Solver.cpp	/^double Solver::progressEstimate() const$/;"	f	class:Solver
progress_estimate	minisat/Solver.h	/^    double              progress_estimate;\/\/ Set by 'search()'.$/;"	m	class:Minisat::Solver
propagate	minisat/Solver.cpp	/^CRef Solver::propagate()$/;"	f	class:Solver
propagation_budget	minisat/Solver.h	/^    int64_t             propagation_budget; \/\/ -1 means no budget.$/;"	m	class:Minisat::Solver
propagations	minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
push	minisat/Vec.h	/^    void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); new (&data[sz++]) T(elem); }$/;"	f	class:Minisat::vec
push	minisat/Vec.h	/^    void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }$/;"	f	class:Minisat::vec
pushBackFanout	cir/cirGate.h	/^	void pushBackFanout(CirGateV gateV) 			{ _out.push_back(gateV); }$/;"	f	class:CirGate
push_	minisat/Vec.h	/^    void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }$/;"	f	class:Minisat::vec
qhead	minisat/Solver.h	/^    int                 qhead;            \/\/ Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).$/;"	m	class:Minisat::Solver
ra	minisat/SolverTypes.h	/^    RegionAllocator<uint32_t> ra;$/;"	m	class:Minisat::ClauseAllocator
randomShuffle	minisat/Rnd.h	/^static void randomShuffle(double& seed, vec<T>& xs)$/;"	f	namespace:Minisat
randomShuffle	minisat/Rnd.h	/^static void randomShuffle(double& seed, vec<vec<T> >& xs)$/;"	f	namespace:Minisat
random_seed	minisat/Solver.h	/^    double    random_seed;$/;"	m	class:Minisat::Solver
random_var_freq	minisat/Solver.h	/^    double    random_var_freq;$/;"	m	class:Minisat::Solver
range	minisat/Options.h	/^    DoubleRange range;$/;"	m	class:Minisat::DoubleOption
range	minisat/Options.h	/^    Int64Range range;$/;"	m	class:Minisat::Int64Option
range	minisat/Options.h	/^    IntRange range;$/;"	m	class:Minisat::IntOption
readUntil	util/parse.h	/^std::string readUntil(std::ifstream& ifs, char end) {$/;"	f
readVerilog	cir/cirParse.cpp	/^CirMgr::readVerilog(const string& filename, bool isF)$/;"	f	class:CirMgr
reason	minisat/Solver.h	/^    struct VarData { CRef reason; int level; };$/;"	m	struct:Minisat::Solver::VarData
reason	minisat/Solver.h	/^inline CRef Solver::reason(Var x) const { return vardata[x].reason; }$/;"	f	class:Minisat::Solver
rebuildOrderHeap	minisat/Solver.cpp	/^void Solver::rebuildOrderHeap()$/;"	f	class:Solver
reduceDB	minisat/Solver.cpp	/^void Solver::reduceDB()$/;"	f	class:Solver
reduceDB_lt	minisat/Solver.cpp	/^    reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}$/;"	f	struct:reduceDB_lt
reduceDB_lt	minisat/Solver.cpp	/^struct reduceDB_lt { $/;"	s	file:
rehash	minisat/Map.h	/^    void    rehash () {$/;"	f	class:Minisat::Map
rel	minisat/SolverTypes.h	/^    union { Lit lit; float act; uint32_t abs; CRef rel; } data[0];$/;"	m	union:Minisat::Clause::__anon5
releaseVar	minisat/Solver.cpp	/^void Solver::releaseVar(Lit l)$/;"	f	class:Solver
released_vars	minisat/Solver.h	/^    vec<Var>            released_vars;$/;"	m	class:Minisat::Solver
reloc	minisat/SolverTypes.h	/^    void reloc(CRef& cr, ClauseAllocator& to)$/;"	f	class:Minisat::ClauseAllocator
relocAll	minisat/Solver.cpp	/^void Solver::relocAll(ClauseAllocator& to)$/;"	f	class:Solver
relocate	minisat/SolverTypes.h	/^    void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }$/;"	f	class:Minisat::Clause
relocation	minisat/SolverTypes.h	/^    CRef         relocation  ()      const   { return data[0].rel; }$/;"	f	class:Minisat::Clause
reloced	minisat/SolverTypes.h	/^        unsigned reloced   : 1;$/;"	m	struct:Minisat::Clause::__anon4
reloced	minisat/SolverTypes.h	/^    bool         reloced     ()      const   { return header.reloced; }$/;"	f	class:Minisat::Clause
remove	minisat/Alg.h	/^static inline void remove(V& ts, const T& t)$/;"	f	namespace:Minisat
remove	minisat/Heap.h	/^    void remove(K k)$/;"	f	class:Minisat::Heap
remove	minisat/Map.h	/^    void remove(const K& k) {$/;"	f	class:Minisat::Map
remove	minisat/SolverTypes.h	/^    void     remove      (CRef cr)            { map.remove(cr); }$/;"	f	class:Minisat::CMap
removeClause	minisat/Solver.cpp	/^void Solver::removeClause(CRef cr) {$/;"	f	class:Solver
removeComment	cir/cirParse.cpp	/^bool CirMgr::removeComment(const std::string& inFilename,$/;"	f	class:CirMgr
removeMin	minisat/Heap.h	/^    K removeMin()$/;"	f	class:Minisat::Heap
removeSatisfied	minisat/Solver.cpp	/^void Solver::removeSatisfied(vec<CRef>& cs)$/;"	f	class:Solver
remove_satisfied	minisat/Solver.h	/^    bool                remove_satisfied; \/\/ Indicates whether possibly inefficient linear scan for satisfied clauses should be performed in 'simplify'.$/;"	m	class:Minisat::Solver
report	cir/cirGate.cpp	/^CirAndGate::report() const$/;"	f	class:CirAndGate
report	cir/cirGate.cpp	/^CirBufGate::report() const$/;"	f	class:CirBufGate
report	cir/cirGate.cpp	/^CirConstGate::report() const$/;"	f	class:CirConstGate
report	cir/cirGate.cpp	/^CirErrorGate::report() const$/;"	f	class:CirErrorGate
report	cir/cirGate.cpp	/^CirInvGate::report() const$/;"	f	class:CirInvGate
report	cir/cirGate.cpp	/^CirNandGate::report() const$/;"	f	class:CirNandGate
report	cir/cirGate.cpp	/^CirNorGate::report() const$/;"	f	class:CirNorGate
report	cir/cirGate.cpp	/^CirOrGate::report() const$/;"	f	class:CirOrGate
report	cir/cirGate.cpp	/^CirPiGate::report() const$/;"	f	class:CirPiGate
report	cir/cirGate.cpp	/^CirPoGate::report() const$/;"	f	class:CirPoGate
report	cir/cirGate.cpp	/^CirXnorGate::report() const$/;"	f	class:CirXnorGate
report	cir/cirGate.cpp	/^CirXorGate::report() const$/;"	f	class:CirXorGate
report	util/myUsage.h	/^   void report(bool repTime, bool repMem) {$/;"	f	class:MyUsage
reportGateAll	cir/cirReport.cpp	/^CirNet::reportGateAll() const$/;"	f	class:CirNet
reportNetList	cir/cirReport.cpp	/^CirNet::reportNetList() const$/;"	f	class:CirNet
reportNetListRec	cir/cirReport.cpp	/^CirNet::reportNetListRec(CirGate* g, unsigned level) const$/;"	f	class:CirNet
reportTopoList	cir/cirReport.cpp	/^CirNet::reportTopoList() const$/;"	f	class:CirNet
reserve	minisat/IntMap.h	/^        void     reserve(K key)              { map.growTo(index(key)+1); }$/;"	f	class:Minisat::IntMap
reserve	minisat/IntMap.h	/^        void     reserve(K key, V pad)       { map.growTo(index(key)+1, pad); }$/;"	f	class:Minisat::IntMap
reset	util/myUsage.h	/^   void reset() {$/;"	f	class:MyUsage
restart_first	minisat/Solver.h	/^    int       restart_first;      \/\/ The initial restart limit.                                                                (default 100)$/;"	m	class:Minisat::Solver
restart_inc	minisat/Solver.h	/^    double    restart_inc;        \/\/ The factor with which the restart limit is multiplied in each restart.                    (default 1.5)$/;"	m	class:Minisat::Solver
right	minisat/Heap.h	/^    static inline int right (int i) { return (i+1)*2; }$/;"	f	class:Minisat::Heap
rnd_decisions	minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
rnd_init_act	minisat/Solver.h	/^    bool      rnd_init_act;       \/\/ Initialize variable activities with a small random value.$/;"	m	class:Minisat::Solver
rnd_pol	minisat/Solver.h	/^    bool      rnd_pol;            \/\/ Use random polarities for branching heuristics.$/;"	m	class:Minisat::Solver
satisfied	minisat/Solver.cpp	/^bool Solver::satisfied(const Clause& c) const {$/;"	f	class:Solver
search	minisat/Solver.cpp	/^lbool Solver::search(int nof_conflicts)$/;"	f	class:Solver
seen	minisat/Solver.h	/^    VMap<char>          seen;$/;"	m	class:Minisat::Solver
selectionSort	minisat/Sort.h	/^template <class T> static inline void selectionSort(T* array, int size) {$/;"	f	namespace:Minisat
selectionSort	minisat/Sort.h	/^void selectionSort(T* array, int size, LessThan lt)$/;"	f	namespace:Minisat
setConfBudget	minisat/Solver.h	/^inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }$/;"	f	class:Minisat::Solver
setDecisionVar	minisat/Solver.h	/^inline void     Solver::setDecisionVar(Var v, bool b) $/;"	f	class:Minisat::Solver
setFanin	cir/cirGate.h	/^	void setFanin(CirGateV gateV, unsigned idx) 	{ _in[idx] = gateV; }$/;"	f	class:CirGate
setFaninSize	cir/cirGate.h	/^	void setFaninSize(unsigned s) 					{ _in.resize(s); }$/;"	f	class:CirGate
setFanout	cir/cirGate.h	/^	void setFanout(CirGateV gateV, unsigned idx) 	{ _out[idx] = gateV; }$/;"	f	class:CirGate
setFanoutSize	cir/cirGate.h	/^	void setFanoutSize(unsigned s) 					{ _out.resize(s); }$/;"	f	class:CirGate
setHelpPrefixStr	minisat/Options.cpp	/^void Minisat::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }$/;"	f	class:Minisat
setId	cir/cirGate.h	/^	void setId(unsigned i) 			{ _id = i; }$/;"	f	class:CirGate
setInv	cir/cirGate.h	/^	void setInv() { _gateV |= (size_t)INV_MASK; }$/;"	f	class:CirGateV
setMemUsage	util/myUsage.h	/^   void setMemUsage() { _currentMem = checkMem() - _initMem; }$/;"	f	class:MyUsage
setName	cir/cirMgr.h	/^	void setName(const string& n ) { _name = n; }$/;"	f	class:CirMgr
setName	cir/cirNet.h	/^	void setName(const string& n ) { _name = n; }$/;"	f	class:CirNet
setPolarity	minisat/Solver.h	/^inline void     Solver::setPolarity   (Var v, lbool b){ user_pol[v] = b; }$/;"	f	class:Minisat::Solver
setPropBudget	minisat/Solver.h	/^inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }$/;"	f	class:Minisat::Solver
setRndFreq	minisat/sat.h	/^  void setRndFreq(double freq) { solver_->random_var_freq = freq; }$/;"	f	class:SatSolver
setTimeUsage	util/myUsage.h	/^   void setTimeUsage() {$/;"	f	class:MyUsage
setToRef	cir/cirGate.h	/^	void setToRef() 		{ _ref = _globalRef; }$/;"	f	class:CirGate
setUsageHelp	minisat/Options.cpp	/^void Minisat::setUsageHelp      (const char* str){ Option::getUsageString() = str; }$/;"	f	class:Minisat
setX86FPUPrecision	minisat/System.cpp	/^void Minisat::setX86FPUPrecision()$/;"	f	class:Minisat
shrink	minisat/SolverTypes.h	/^    void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }$/;"	f	class:Minisat::Clause
shrink	minisat/Vec.h	/^    void     shrink   (Size nelems)  { assert(nelems <= sz); for (Size i = 0; i < nelems; i++) sz--, data[sz].~T(); }$/;"	f	class:Minisat::vec
shrink_	minisat/Vec.h	/^    void     shrink_  (Size nelems)  { assert(nelems <= sz); sz -= nelems; }$/;"	f	class:Minisat::vec
sigTerm	minisat/System.cpp	/^void Minisat::sigTerm(void handler(int))$/;"	f	class:Minisat
sign	minisat/SolverTypes.h	/^inline  bool sign      (Lit p)              { return p.x & 1; }$/;"	f	namespace:Minisat
simpDB_assigns	minisat/Solver.h	/^    int                 simpDB_assigns;   \/\/ Number of top-level assignments since last execution of 'simplify()'.$/;"	m	class:Minisat::Solver
simpDB_props	minisat/Solver.h	/^    int64_t             simpDB_props;     \/\/ Remaining number of propagations that must be made before next execution of 'simplify()'.$/;"	m	class:Minisat::Solver
simplify	minisat/Solver.cpp	/^bool Solver::simplify()$/;"	f	class:Solver
simplify	minisat/sat.h	/^  void simplify() { solver_->simplify(); }$/;"	f	class:SatSolver
size	minisat/Alloc.h	/^    uint32_t size      () const      { return sz; }$/;"	f	class:Minisat::RegionAllocator
size	minisat/Heap.h	/^    int  size      ()          const { return heap.size(); }$/;"	f	class:Minisat::Heap
size	minisat/IntMap.h	/^        int      size        (void)      const  { return xs.size(); }$/;"	f	class:Minisat::IntSet
size	minisat/Map.h	/^    int        size;$/;"	m	class:Minisat::Map
size	minisat/ParseUtils.h	/^    int            size;$/;"	m	class:Minisat::StreamBuffer
size	minisat/Queue.h	/^    int  size  () const { return (end >= first) ? end - first : end - first + buf.size(); }$/;"	f	class:Minisat::Queue
size	minisat/SolverTypes.h	/^        unsigned size      : 27; }                        header;$/;"	m	struct:Minisat::Clause::__anon4
size	minisat/SolverTypes.h	/^    int          size        ()      const   { return header.size; }$/;"	f	class:Minisat::Clause
size	minisat/SolverTypes.h	/^    int      size        ()                const      { return map.elems(); }$/;"	f	class:Minisat::CMap
size	minisat/SolverTypes.h	/^    uint32_t size      () const      { return ra.size(); }$/;"	f	class:Minisat::ClauseAllocator
size	minisat/Vec.h	/^    Size     size     (void) const   { return sz; }$/;"	f	class:Minisat::vec
skipLine	minisat/ParseUtils.h	/^static void skipLine(B& in) {$/;"	f	namespace:Minisat
skipWhitespace	minisat/ParseUtils.h	/^static void skipWhitespace(B& in) {$/;"	f	namespace:Minisat
smudge	minisat/SolverTypes.h	/^    void  smudge    (const K& idx){$/;"	f	class:Minisat::OccLists
solve	minisat/Solver.h	/^inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solve	minisat/Solver.h	/^inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solve	minisat/Solver.h	/^inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solve	minisat/Solver.h	/^inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solve	minisat/Solver.h	/^inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == l_True; }$/;"	f	class:Minisat::Solver
solve	minisat/sat.h	/^  bool solve() { return solver_->solve(); }$/;"	f	class:SatSolver
solve	minisat/sat.h	/^  bool solve(Var var, bool val) { return solver_->solve(mkLit(var, !val)); }$/;"	f	class:SatSolver
solve	minisat/sat.h	/^  bool solve(const vec<Lit>& assump) {$/;"	f	class:SatSolver
solveLimited	minisat/Solver.h	/^inline lbool    Solver::solveLimited  (const vec<Lit>& assumps){ assumps.copyTo(assumptions); return solve_(); }$/;"	f	class:Minisat::Solver
solveLimited	minisat/sat.h	/^  lbool solveLimited(Var var, bool val, int64_t budget) {$/;"	f	class:SatSolver
solveLimited	minisat/sat.h	/^  lbool solveLimited(const vec<Lit>& assump, int64_t budget) {$/;"	f	class:SatSolver
solveLimited	minisat/sat.h	/^  lbool solveLimited(int64_t budget) {$/;"	f	class:SatSolver
solve_	minisat/Solver.cpp	/^lbool Solver::solve_()$/;"	f	class:Solver
solver_	minisat/sat.h	/^  Solver* solver_;$/;"	m	class:SatSolver
solves	minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
sort	minisat/Sort.h	/^template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {$/;"	f	namespace:Minisat
sort	minisat/Sort.h	/^template <class T> static inline void sort(T* array, int size) {$/;"	f	namespace:Minisat
sort	minisat/Sort.h	/^template <class T> void sort(vec<T>& v) {$/;"	f	namespace:Minisat
sort	minisat/Sort.h	/^void sort(T* array, int size, LessThan lt)$/;"	f	namespace:Minisat
split	util/parse.h	/^std::vector<std::string> split(const std::string& str, const std::string& sep) {$/;"	f
starts	minisat/Solver.h	/^    uint64_t solves, starts, decisions, rnd_decisions, propagations, conflicts;$/;"	m	class:Minisat::Solver
strengthen	minisat/SolverTypes.h	/^inline void Clause::strengthen(Lit p)$/;"	f	class:Minisat::Clause
subsumes	minisat/SolverTypes.h	/^inline Lit Clause::subsumes(const Clause& other) const$/;"	f	class:Minisat::Clause
sz	minisat/Alloc.h	/^    uint32_t  sz;$/;"	m	class:Minisat::RegionAllocator
sz	minisat/Vec.h	/^    Size sz;$/;"	m	class:Minisat::vec
table	minisat/Map.h	/^    vec<Pair>* table;$/;"	m	class:Minisat::Map
toDimacs	minisat/Solver.cpp	/^void Solver::toDimacs(FILE* f, Clause& c, vec<Var>& map, Var& max)$/;"	f	class:Solver
toDimacs	minisat/Solver.cpp	/^void Solver::toDimacs(FILE* f, const vec<Lit>& assumps)$/;"	f	class:Solver
toDimacs	minisat/Solver.cpp	/^void Solver::toDimacs(const char *file, const vec<Lit>& assumps)$/;"	f	class:Solver
toDimacs	minisat/Solver.h	/^inline void     Solver::toDimacs     (const char* file){ vec<Lit> as; toDimacs(file, as); }$/;"	f	class:Minisat::Solver
toDimacs	minisat/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p){ vec<Lit> as; as.push(p); toDimacs(file, as); }$/;"	f	class:Minisat::Solver
toDimacs	minisat/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p, Lit q){ vec<Lit> as; as.push(p); as.push(q); toDimacs(file, as); }$/;"	f	class:Minisat::Solver
toDimacs	minisat/Solver.h	/^inline void     Solver::toDimacs     (const char* file, Lit p, Lit q, Lit r){ vec<Lit> as; as.push(p); as.push(q); as.push(r); toDimacs(file, as); }$/;"	f	class:Minisat::Solver
toInt	minisat/SolverTypes.h	/^inline  int  toInt     (Lit p)              { return p.x; } $/;"	f	namespace:Minisat
toInt	minisat/SolverTypes.h	/^inline  int  toInt     (Var v)              { return v; } $/;"	f	namespace:Minisat
toInt	minisat/SolverTypes.h	/^inline int   toInt  (lbool l) { return l.value; }$/;"	f	namespace:Minisat
toLbool	minisat/SolverTypes.h	/^inline lbool toLbool(int   v) { return lbool((uint8_t)v);  }$/;"	f	namespace:Minisat
toLit	minisat/SolverTypes.h	/^inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } $/;"	f	namespace:Minisat
toVec	minisat/IntMap.h	/^                 toVec       ()          const  { return xs; }$/;"	f	class:Minisat::IntSet
tot_literals	minisat/Solver.h	/^    uint64_t dec_vars, num_clauses, num_learnts, clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	class:Minisat::Solver
trail	minisat/Solver.h	/^    vec<Lit>            trail;            \/\/ Assignment stack; stores all assigments made in the order they were made.$/;"	m	class:Minisat::Solver
trailBegin	minisat/Solver.h	/^inline TrailIterator  Solver::trailBegin  () const { return TrailIterator(&trail[0]); }$/;"	f	class:Minisat::Solver
trailEnd	minisat/Solver.h	/^inline TrailIterator  Solver::trailEnd    () const { $/;"	f	class:Minisat::Solver
trail_lim	minisat/Solver.h	/^    vec<int>            trail_lim;        \/\/ Separator indices for different decision levels in 'trail'.$/;"	m	class:Minisat::Solver
type_name	minisat/Options.h	/^    const char* type_name;$/;"	m	class:Minisat::Option
uncheckedEnqueue	minisat/Solver.cpp	/^void Solver::uncheckedEnqueue(Lit p, CRef from)$/;"	f	class:Solver
update	minisat/Heap.h	/^    void update(K k)$/;"	f	class:Minisat::Heap
user_pol	minisat/Solver.h	/^    VMap<lbool>         user_pol;         \/\/ The users preferred polarity of each variable.$/;"	m	class:Minisat::Solver
val_	util/unate.h	/^  unsigned val_;$/;"	m	class:Unateness
value	minisat/Options.h	/^    bool value;$/;"	m	class:Minisat::BoolOption
value	minisat/Options.h	/^    const char* value;$/;"	m	class:Minisat::StringOption
value	minisat/Options.h	/^    double      value;$/;"	m	class:Minisat::DoubleOption
value	minisat/Options.h	/^    int32_t  value;$/;"	m	class:Minisat::IntOption
value	minisat/Options.h	/^    int64_t  value;$/;"	m	class:Minisat::Int64Option
value	minisat/Solver.h	/^inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }$/;"	f	class:Minisat::Solver
value	minisat/Solver.h	/^inline lbool    Solver::value         (Var x) const   { return assigns[x]; }$/;"	f	class:Minisat::Solver
value	minisat/SolverTypes.h	/^    uint8_t value;$/;"	m	class:Minisat::lbool
value	util/bool3v.h	/^  unsigned value;$/;"	m	class:bool_3v
var	minisat/SolverTypes.h	/^inline  int  var       (Lit p)              { return p.x >> 1; }$/;"	f	namespace:Minisat
varBumpActivity	minisat/Solver.h	/^inline void Solver::varBumpActivity(Var v) { varBumpActivity(v, var_inc); }$/;"	f	class:Minisat::Solver
varBumpActivity	minisat/Solver.h	/^inline void Solver::varBumpActivity(Var v, double inc) {$/;"	f	class:Minisat::Solver
varDecayActivity	minisat/Solver.h	/^inline void Solver::varDecayActivity() { var_inc *= (1 \/ var_decay); }$/;"	f	class:Minisat::Solver
var_Undef	minisat/SolverTypes.h	/^  const Var var_Undef = -1;$/;"	m	namespace:Minisat
var_Undef	minisat/SolverTypes.h	45;"	d
var_decay	minisat/Solver.h	/^    double    var_decay;$/;"	m	class:Minisat::Solver
var_inc	minisat/Solver.h	/^    double              var_inc;          \/\/ Amount to bump next variable with.$/;"	m	class:Minisat::Solver
vardata	minisat/Solver.h	/^    VMap<VarData>       vardata;          \/\/ Stores reason and level for each variable.$/;"	m	class:Minisat::Solver
vec	minisat/Vec.h	/^    explicit vec(Size size)      : data(NULL), sz(0), cap(0)    { growTo(size); }$/;"	f	class:Minisat::vec
vec	minisat/Vec.h	/^    vec()                        : data(NULL), sz(0), cap(0)    { }$/;"	f	class:Minisat::vec
vec	minisat/Vec.h	/^    vec(Size size, const T& pad) : data(NULL), sz(0), cap(0)    { growTo(size, pad); }$/;"	f	class:Minisat::vec
vec	minisat/Vec.h	/^class vec {$/;"	c	namespace:Minisat
verbosity	minisat/Solver.h	/^    int       verbosity;$/;"	m	class:Minisat::Solver
wasted	minisat/Alloc.h	/^    uint32_t wasted    () const      { return wasted_; }$/;"	f	class:Minisat::RegionAllocator
wasted	minisat/SolverTypes.h	/^    uint32_t wasted    () const      { return ra.wasted(); }$/;"	f	class:Minisat::ClauseAllocator
wasted_	minisat/Alloc.h	/^    uint32_t  wasted_;$/;"	m	class:Minisat::RegionAllocator
watches	minisat/Solver.h	/^                        watches;          \/\/ 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).$/;"	m	class:Minisat::Solver
withinBudget	minisat/Solver.h	/^inline bool     Solver::withinBudget() const {$/;"	f	class:Minisat::Solver
x	minisat/SolverTypes.h	/^    int     x;$/;"	m	struct:Minisat::Lit
xrealloc	minisat/XAlloc.h	/^static inline void* xrealloc(void *ptr, size_t size)$/;"	f	namespace:Minisat
xs	minisat/IntMap.h	/^        vec<K>                   xs;$/;"	m	class:Minisat::IntSet
~CirGate	cir/cirGate.h	/^	virtual ~CirGate() {}$/;"	f	class:CirGate
~CirGateV	cir/cirGate.h	/^	~CirGateV() {}$/;"	f	class:CirGateV
~CirMgr	cir/cirMgr.h	/^	~CirMgr() {}\/\/{ delete _F; delete _G; delete _patch; }$/;"	f	class:CirMgr
~CirNet	cir/cirNet.cpp	/^CirNet::~CirNet()$/;"	f	class:CirNet
~Map	minisat/Map.h	/^    ~Map () { delete [] table; }$/;"	f	class:Minisat::Map
~Option	minisat/Options.h	/^    virtual ~Option() {}$/;"	f	class:Minisat::Option
~RegionAllocator	minisat/Alloc.h	/^    ~RegionAllocator()$/;"	f	class:Minisat::RegionAllocator
~SatSolver	minisat/sat.h	/^  ~SatSolver() {$/;"	f	class:SatSolver
~Solver	minisat/Solver.cpp	/^Solver::~Solver()$/;"	f	class:Solver
~StreamBuffer	minisat/ParseUtils.h	/^    ~StreamBuffer() { free(buf); }$/;"	f	class:Minisat::StreamBuffer
~Unateness	util/unate.h	/^  ~Unateness() {}$/;"	f	class:Unateness
~vec	minisat/Vec.h	/^   ~vec()                                                       { clear(true); }$/;"	f	class:Minisat::vec
