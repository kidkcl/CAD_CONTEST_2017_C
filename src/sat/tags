!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BUF_SIZE	reader.h	17;"	d
CC_MINIMIZATION	SolverV.cpp	26;"	d	file:
Clause	SolverTypesV.h	/^    Clause(bool learnt, const vec<Lit>& ps, ClauseId id_ = ClauseId_NULL) {$/;"	f	class:Clause
Clause	SolverTypesV.h	/^class Clause {$/;"	c
ClauseId	SolverTypesV.h	/^typedef int ClauseId;     \/\/ (might have to use uint64 one day...)$/;"	t
ClauseId_NULL	SolverTypesV.h	/^const   int ClauseId_NULL = INT_MIN;$/;"	v
Clause_new	SolverTypesV.h	/^inline Clause* Clause_new(bool learnt, const vec<Lit>& ps, ClauseId id = ClauseId_NULL) {$/;"	f
Current_Pos	reader.h	/^	unsigned int Current_Pos()	{ return overall_pos; }$/;"	f	class:Reader
DEFAULTS	FileV.h	40;"	d
DEFAULTS	FileV.h	48;"	d
Datum	GlobalV.h	/^    typedef T   Datum;$/;"	t	class:vec
Exception_EOF	FileV.h	/^class Exception_EOF {};$/;"	c
File	FileV.h	/^    File(cchar* name, cchar* mode) : DEFAULTS {$/;"	f	class:File
File	FileV.h	/^    File(int fd, FileMode mode, bool own_fd = true) : DEFAULTS  {$/;"	f	class:File
File	FileV.h	/^    File(void) : DEFAULTS {}$/;"	f	class:File
File	FileV.h	/^class File {$/;"	c
FileMode	FileV.h	/^enum FileMode { READ, WRITE };$/;"	g
File_BufSize	FileV.h	22;"	d
File_h	FileV.h	2;"	d
GClause	SolverTypesV.h	/^    GClause(void* d) : data(d) {}$/;"	f	class:GClause
GClause	SolverTypesV.h	/^class GClause {$/;"	c
GClause_NULL	SolverTypesV.h	143;"	d
GClause_new	SolverTypesV.h	/^inline GClause GClause_new(Clause* c) { assert(((uintp)c & 1) == 0); return GClause((void*)c); }$/;"	f
GClause_new	SolverTypesV.h	/^inline GClause GClause_new(Lit p)     { return GClause((void*)(((intp)index(p) << 1) + 1)); }$/;"	f
Global_h	GlobalV.h	21;"	d
Heap	HeapV.h	/^    Heap(C c) : comp(c) { heap.push(-1); }$/;"	f	class:Heap
Heap	HeapV.h	/^class Heap {$/;"	c
Heap_h	HeapV.h	21;"	d
I64_fmt	GlobalV.h	41;"	d
I64_fmt	GlobalV.h	47;"	d
Key	GlobalV.h	/^    typedef int Key;$/;"	t	class:vec
L_LIT	SolverV.h	227;"	d
L_lit	SolverV.h	228;"	d
LessThan_default	SortV.h	/^struct LessThan_default {$/;"	s
Lit	SolverTypesV.h	/^    Lit() : x(2*var_Undef) {}   \/\/ (lit_Undef)$/;"	f	class:Lit
Lit	SolverTypesV.h	/^    explicit Lit(Var var, bool sgn = false) : x((var+var) + (int)sgn) {}$/;"	f	class:Lit
Lit	SolverTypesV.h	/^class Lit {$/;"	c
Proof	ProofV.cpp	/^Proof::Proof()$/;"	f	class:Proof
Proof	ProofV.cpp	/^Proof::Proof(ProofTraverser& t)$/;"	f	class:Proof
Proof	ProofV.h	/^class Proof {$/;"	c
ProofTraverser	ProofV.h	/^struct ProofTraverser {$/;"	s
Proof_h	ProofV.h	21;"	d
RDR_EOF	reader.h	18;"	d
READ	FileV.h	/^enum FileMode { READ, WRITE };$/;"	e	enum:FileMode
Reader	reader.h	/^	Reader():fd(-1)				{};$/;"	f	class:Reader
Reader	reader.h	/^class Reader{$/;"	c
SAT_C	sat.cpp	10;"	d	file:
SAT_H	sat.h	10;"	d
STATIC_ASSERTION_FAILURE	GlobalV.h	/^template <> struct STATIC_ASSERTION_FAILURE<true>{};$/;"	s
SatSolverV	sat.cpp	/^SatSolverV::SatSolverV()$/;"	f	class:SatSolverV
SatSolverV	sat.h	/^class SatSolverV$/;"	c
SearchParams	SolverV.h	/^    SearchParams(double v = 1, double c = 1, double r = 0) : var_decay(v), clause_decay(c), random_var_freq(r) { }$/;"	f	struct:SearchParams
SearchParams	SolverV.h	/^struct SearchParams {$/;"	s
SolverStats	SolverV.h	/^    SolverStats() : starts(0), decisions(0), propagations(0), conflicts(0)$/;"	f	struct:SolverStats
SolverStats	SolverV.h	/^struct SolverStats {$/;"	s
SolverTypes_h	SolverTypesV.h	22;"	d
SolverV	SolverV.h	/^    SolverV() : ok               (true)$/;"	f	class:SolverV
SolverV	SolverV.h	/^class SolverV {$/;"	c
Solver_h	SolverV.h	21;"	d
Sort_h	SortV.h	21;"	d
TEMPLATE_FAIL	GlobalV.h	58;"	d
TempFiles	ProofV.cpp	/^class TempFiles {$/;"	c	file:
Var	SolverTypesV.h	/^typedef int Var;$/;"	t
VarOrder	VarOrderV.h	/^    VarOrder(const vec<char>& ass, const vec<double>& act) :$/;"	f	class:VarOrder
VarOrder	VarOrderV.h	/^class VarOrder {$/;"	c
VarOrder_h	VarOrderV.h	21;"	d
VarOrder_lt	VarOrderV.h	/^    VarOrder_lt(const vec<double>&  act) : activity(act) { }$/;"	f	struct:VarOrder_lt
VarOrder_lt	VarOrderV.h	/^struct VarOrder_lt {$/;"	s
WRITE	FileV.h	/^enum FileMode { READ, WRITE };$/;"	e	enum:FileMode
_READER_H_	reader.h	10;"	d
__SGI_STL_INTERNAL_RELOPS	GlobalV.h	276;"	d
_aborted	SolverV.h	/^   bool     _aborted;$/;"	m	class:SolverV
_assump	sat.h	/^      vec<Lit>            _assump;    \/\/ Assumption List for assumption solve$/;"	m	class:SatSolverV
_conflictNum	SolverV.h	/^   int      _conflictNum;$/;"	m	class:SolverV
_curVar	sat.h	/^      Var                 _curVar;    \/\/ Variable currently$/;"	m	class:SatSolverV
_solver	sat.h	/^      SolverV            *_solver;    \/\/ Pointer to a Minisat solver$/;"	m	class:SatSolverV
_zeroFirst	SolverV.h	/^	bool		_zeroFirst;$/;"	m	class:SolverV
activity	SolverTypesV.h	/^    float&    activity    ()      const { return *((float*)&data[size()]); }$/;"	f	class:Clause
activity	SolverV.h	/^    vec<double>         activity;         \/\/ A heuristic measurement of the activity of a variable.$/;"	m	class:SolverV
activity	VarOrderV.h	/^    const vec<double>&  activity;    \/\/ var->act. Pointer to external activity table.$/;"	m	class:VarOrder
activity	VarOrderV.h	/^    const vec<double>&  activity;$/;"	m	struct:VarOrder_lt
addAndCNF	sat.cpp	/^void SatSolverV::addAndCNF(Var out, Var in0, bool inv0, Var in1, bool inv1)$/;"	f	class:SatSolverV
addAndCNF	sat.cpp	/^void SatSolverV::addAndCNF(Var out, const vector<Var>& rms)$/;"	f	class:SatSolverV
addBinary	SolverV.h	/^    void    addBinary (Lit p, Lit q)        { addBinary_tmp [0] = p; addBinary_tmp [1] = q; addClause(addBinary_tmp); }$/;"	f	class:SolverV
addBinary	sat.h	/^      void addBinary(Lit lit0, Lit lit1) { _solver->addBinary(lit0, lit1); }$/;"	f	class:SatSolverV
addBinary_tmp	SolverV.h	/^    vec<Lit>            addBinary_tmp;$/;"	m	class:SolverV
addClause	SolverV.h	/^    void    addClause (const vec<Lit>& ps )  { if (okay()) newClause(ps); }  \/\/ (used to be a difference between internal and external method...)$/;"	f	class:SolverV
addClause	sat.h	/^      void addClause(const vec<Lit>& clause) { _solver->addClause(clause); }$/;"	f	class:SatSolverV
addEqCNF	sat.cpp	/^void SatSolverV::addEqCNF(Var var0, Var var1, bool inv)$/;"	f	class:SatSolverV
addMuxCNF	sat.cpp	/^void SatSolverV::addMuxCNF(Var out, Var in0, bool inv0, Var in1, bool inv1, Var sel, bool invSel)$/;"	f	class:SatSolverV
addOrCNF	sat.cpp	/^void SatSolverV::addOrCNF(Var out, Var in0, bool inv0, Var in1, bool inv1)$/;"	f	class:SatSolverV
addOrCNF	sat.cpp	/^void SatSolverV::addOrCNF(Var out, const vector<Var>& Xors)$/;"	f	class:SatSolverV
addRoot	ProofV.cpp	/^ClauseId Proof::addRoot(vec<Lit>& cl)$/;"	f	class:Proof
addTernary	SolverV.h	/^    void    addTernary(Lit p, Lit q, Lit r) { addTernary_tmp[0] = p; addTernary_tmp[1] = q; addTernary_tmp[2] = r; addClause(addTernary_tmp); }$/;"	f	class:SolverV
addTernary	sat.h	/^      void addTernary(Lit lit0, Lit lit1, Lit lit2) { _solver->addTernary(lit0, lit1, lit2); }$/;"	f	class:SatSolverV
addTernary_tmp	SolverV.h	/^    vec<Lit>            addTernary_tmp;$/;"	m	class:SolverV
addUnit	SolverV.h	/^    void    addUnit   (Lit p)               { addUnit_tmp   [0] = p; addClause(addUnit_tmp); }$/;"	f	class:SolverV
addUnit	sat.h	/^      void addUnit(Lit lit0) { _solver->addUnit(lit0); }$/;"	f	class:SatSolverV
addUnitCNF	sat.cpp	/^void SatSolverV::addUnitCNF(Var var, bool val)$/;"	f	class:SatSolverV
addUnit_tmp	SolverV.h	/^    vec<Lit>            addUnit_tmp;$/;"	m	class:SolverV
addXnorCNF	sat.cpp	/^void SatSolverV::addXnorCNF(Var out, Var in0, bool inv0, Var in1, bool inv1)$/;"	f	class:SatSolverV
addXorCNF	sat.cpp	/^void SatSolverV::addXorCNF(Var out, Var in0, bool inv0, Var in1, bool inv1)$/;"	f	class:SatSolverV
analyze	SolverV.cpp	/^void SolverV::analyze(Clause* confl, vec<Lit>& out_learnt, int& out_btlevel)$/;"	f	class:SolverV
analyzeFinal	SolverV.cpp	/^void SolverV::analyzeFinal(Clause* confl, bool skip_first)$/;"	f	class:SolverV
analyze_removable	SolverV.cpp	/^bool SolverV::analyze_removable(Lit p, uint min_level)$/;"	f	class:SolverV
analyze_seen	SolverV.h	/^    vec<char>           analyze_seen;$/;"	m	class:SolverV
analyze_stack	SolverV.h	/^    vec<Lit>            analyze_stack;$/;"	m	class:SolverV
analyze_tmpbin	SolverV.h	/^    Clause*             analyze_tmpbin;$/;"	m	class:SolverV
analyze_toclear	SolverV.h	/^    vec<Lit>            analyze_toclear;$/;"	m	class:SolverV
assertProperty	sat.cpp	/^void SatSolverV::assertProperty(const size_t& var, const bool& invert)$/;"	f	class:SatSolverV
assigns	SolverV.h	/^    vec<char>           assigns;          \/\/ The current assignments (lbool:s stored as char:s).$/;"	m	class:SolverV
assigns	VarOrderV.h	/^    const vec<char>&    assigns;     \/\/ var->val. Pointer to external assignment table.$/;"	m	class:VarOrder
assume	SolverV.cpp	/^bool SolverV::assume(Lit p) {$/;"	f	class:SolverV
assumeProperty	sat.cpp	/^void SatSolverV::assumeProperty(const Var& var, const bool& inv)$/;"	f	class:SatSolverV
assumeRelease	sat.cpp	/^void SatSolverV::assumeRelease() { _assump.clear(); }$/;"	f	class:SatSolverV
assump_solve	sat.cpp	/^const bool SatSolverV::assump_solve(bool zeroFirst)$/;"	f	class:SatSolverV
beginChain	ProofV.cpp	/^void Proof::beginChain(ClauseId start)$/;"	f	class:Proof
buf	FileV.h	/^    uchar*      buf;        \/\/ Read or write buffer.$/;"	m	class:File
buf	reader.h	/^	unsigned char* 	buf;$/;"	m	class:Reader
cancelUntil	SolverV.cpp	/^void SolverV::cancelUntil(int level) {$/;"	f	class:SolverV
cap	GlobalV.h	/^    int cap;$/;"	m	class:vec
capacity	GlobalV.h	/^    void     capacity (int size) { grow(size); }$/;"	f	class:vec
cchar	GlobalV.h	/^typedef const char    cchar;$/;"	t
chain	ProofV.h	/^    virtual void chain  (const vec<ClauseId>& cs, const vec<Var>& xs) {}$/;"	f	struct:ProofTraverser
chain_id	ProofV.h	/^    vec<ClauseId>   chain_id;$/;"	m	class:Proof
chain_var	ProofV.h	/^    vec<Var>        chain_var;$/;"	m	class:Proof
check	SolverV.h	/^inline void check(bool expr) { assert(expr); }$/;"	f
claBumpActivity	SolverV.h	/^    void     claBumpActivity (Clause* c) { if ( (c->activity() += cla_inc) > 1e20 ) claRescaleActivity(); }$/;"	f	class:SolverV
claDecayActivity	SolverV.h	/^    void     claDecayActivity  () { cla_inc *= cla_decay; }$/;"	f	class:SolverV
claRescaleActivity	SolverV.cpp	/^void SolverV::claRescaleActivity()$/;"	f	class:SolverV
cla_decay	SolverV.h	/^    double              cla_decay;        \/\/ INVERSE decay factor for clause activity: stores 1\/decay.$/;"	m	class:SolverV
cla_inc	SolverV.h	/^    double              cla_inc;          \/\/ Amount to bump next clause with.$/;"	m	class:SolverV
clause	ProofV.h	/^    vec<Lit>        clause;$/;"	m	class:Proof
clause	SolverTypesV.h	/^    Clause*     clause   () const { return (Clause*)data; }$/;"	f	class:GClause
clause_decay	SolverV.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
clauses	SolverV.h	/^    vec<Clause*>        clauses;          \/\/ List of problem clauses.$/;"	m	class:SolverV
clauses_literals	SolverV.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
clear	GlobalV.h	/^void vec<T>::clear(bool dealloc) {$/;"	f	class:vec
close	FileV.cpp	/^void File::close(void)$/;"	f	class:File
close	reader.cpp	/^void Reader::close(){$/;"	f	class:Reader
comp	HeapV.h	/^    C        comp;$/;"	m	class:Heap
compress	ProofV.cpp	/^void Proof::compress(Proof& dst, ClauseId goal)$/;"	f	class:Proof
conflict	SolverV.h	/^    vec<Lit>    conflict;           \/\/ If problem is unsatisfiable under assumptions, this vector represent the conflict clause expressed in the assumptions.$/;"	m	class:SolverV
conflict_id	SolverV.h	/^    ClauseId    conflict_id;        \/\/ (In proof logging mode only.) ID for the clause 'conflict' (for proof traverseral). NOTE! The empty clause is always the last clause derived, but for conflicts under assumption, this is not necessarly true.$/;"	m	class:SolverV
conflicts	SolverV.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
copyTo	GlobalV.h	/^    void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) new (&copy[i]) T(data[i]); }$/;"	f	class:vec
cpuTime	GlobalV.h	/^static inline double cpuTime(void) {$/;"	f
data	GlobalV.h	/^    T*  data;$/;"	m	class:vec
data	SolverTypesV.h	/^    Lit     data[1];$/;"	m	class:Clause
data	SolverTypesV.h	/^    void*   data;$/;"	m	class:GClause
decisionLevel	SolverV.h	/^    int      decisionLevel() const { return trail_lim.size(); }$/;"	f	class:SolverV
decisions	SolverV.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
decode64	FileV.h	/^static inline int64  decode64(uint64 val)           { return ((val & 1) == 0) ? (int64)(val >> 1) : ~(int64)(val >> 1); }$/;"	f
default_params	SolverV.h	/^    SearchParams    default_params;     \/\/ Restart frequency etc.$/;"	m	class:SolverV
deleted	ProofV.cpp	/^void Proof::deleted(ClauseId gone)$/;"	f	class:Proof
deleted	ProofV.h	/^    virtual void deleted(ClauseId c) {}$/;"	f	struct:ProofTraverser
done	ProofV.h	/^    virtual void done   () {}$/;"	f	struct:ProofTraverser
drand	GlobalV.h	/^static inline double drand(double& seed) {$/;"	f
empty	HeapV.h	/^    bool empty     ()         { return heap.size() == 1; }$/;"	f	class:Heap
encode64	FileV.h	/^static inline uint64 encode64(int64  val)           { return (val >= 0) ? (uint64)val << 1 : (((uint64)(~val) << 1) | 1); }$/;"	f
endChain	ProofV.cpp	/^ClauseId Proof::endChain()$/;"	f	class:Proof
enqueue	SolverV.cpp	/^bool SolverV::enqueue(Lit p, Clause* from)$/;"	f	class:SolverV
eof	FileV.h	/^    bool eof(void) {$/;"	f	class:File
eof	reader.cpp	/^bool Reader::eof() {$/;"	f	class:Reader
expensive_ccmin	SolverV.h	/^    bool            expensive_ccmin;    \/\/ Controls conflict clause minimization. TRUE by default.$/;"	m	class:SolverV
fd	FileV.h	/^    int         fd;         \/\/ Underlying file descriptor.$/;"	m	class:File
fd	reader.h	/^	int 			fd;$/;"	m	class:Reader
files	ProofV.cpp	/^    vec<cchar*> files;      \/\/ For clean-up purposed on abnormal exit.$/;"	m	class:TempFiles	file:
flush	FileV.h	/^    void flush(void) {$/;"	f	class:File
fp	ProofV.h	/^    File            fp;$/;"	m	class:Proof
fp_name	ProofV.h	/^    cchar*          fp_name;$/;"	m	class:Proof
get64	reader.cpp	/^unsigned long long Reader::get64(){$/;"	f	class:Reader
getAssignment	sat.cpp	/^const bool SatSolverV::getAssignment(const Var& v) const$/;"	f	class:SatSolverV
getChar	FileV.h	/^    int getChar(void) {$/;"	f	class:File
getChar	reader.cpp	/^unsigned int Reader::getChar(){$/;"	f	class:Reader
getCharQ	FileV.h	/^    int getCharQ(void) {            \/\/ Quick version with minimal overhead -- don't call this in the wrong mode!$/;"	f	class:File
getDataValue	sat.cpp	/^const bool SatSolverV::getDataValue(const size_t& var) const $/;"	f	class:SatSolverV
getInt	FileV.h	/^static inline uint64 getInt  (File& in)             { return decode64(getUInt(in)); }$/;"	f
getMode	FileV.h	/^    FileMode getMode(void) {$/;"	f	class:File
getNegFormula	sat.h	/^      inline const size_t getNegFormula(const size_t& v) const { return (v ^ 1ul); }$/;"	f	class:SatSolverV
getNegVar	sat.h	/^      inline const size_t getNegVar(const Var& v) const { return ((getPosVar(v)) | 1ul); }$/;"	f	class:SatSolverV
getNumClauses	sat.h	/^      int getNumClauses() const { return _solver->nRootCla(); }$/;"	f	class:SatSolverV
getOriVar	sat.h	/^      inline const Var getOriVar(const size_t& v) const { return (Var)(v >> 1ul); }$/;"	f	class:SatSolverV
getPosVar	sat.h	/^      inline const size_t getPosVar(const Var& v) const { return (((size_t)v) << 1ul); }$/;"	f	class:SatSolverV
getUInt	FileV.cpp	/^uint64 getUInt(File& in)$/;"	f
getmin	HeapV.h	/^    int  getmin() {$/;"	f	class:Heap
grow	GlobalV.h	/^void vec<T>::grow(int min_cap) {$/;"	f	class:vec
growTo	GlobalV.h	/^void vec<T>::growTo(int size) {$/;"	f	class:vec
growTo	GlobalV.h	/^void vec<T>::growTo(int size, const T& pad) {$/;"	f	class:vec
hash	SolverTypesV.h	/^    inline uint hash() const { return (uint)x; }$/;"	f	class:Lit
heap	HeapV.h	/^    vec<int> heap;     \/\/ heap of ints$/;"	m	class:Heap
heap	VarOrderV.h	/^    Heap<VarOrder_lt>   heap;$/;"	m	class:VarOrder
heapProperty	HeapV.h	/^    bool heapProperty() {$/;"	f	class:Heap
heapProperty	HeapV.h	/^    bool heapProperty(int i) {$/;"	f	class:Heap
id	SolverTypesV.h	/^    ClauseId& id          ()      const { return *((ClauseId*)&data[size() + (int)learnt()]); }$/;"	f	class:Clause
id	SolverTypesV.h	/^inline Lit  id    (Lit p, bool sgn) { Lit q; q.x = p.x ^ (int)sgn; return q; }$/;"	f
id_counter	ProofV.h	/^    ClauseId        id_counter;$/;"	m	class:Proof
inHeap	HeapV.h	/^    bool inHeap    (int n)    { assert(ok(n)); return indices[n] != 0; }$/;"	f	class:Heap
increase	HeapV.h	/^    void increase  (int n)    { assert(ok(n)); assert(inHeap(n)); percolateUp(indices[n]); }$/;"	f	class:Heap
index	SolverTypesV.h	/^inline int  index (Lit p) { return p.x; }                \/\/ A "toInt" method that guarantees small, positive integers suitable for array indexing.$/;"	f
indices	HeapV.h	/^    vec<int> indices;  \/\/ int -> index in heap$/;"	m	class:Heap
insert	HeapV.h	/^    void insert(int n) {$/;"	f	class:Heap
int64	GlobalV.h	/^typedef INT64              int64;$/;"	t
int64	GlobalV.h	/^typedef long long          int64;$/;"	t
intp	GlobalV.h	/^typedef INT_PTR            intp;$/;"	t
intp	GlobalV.h	/^typedef __PTRDIFF_TYPE__   intp;$/;"	t
irand	GlobalV.h	/^static inline int irand(double& seed, int size) {$/;"	f
isLit	SolverTypesV.h	/^    bool        isLit    () const { return ((uintp)data & 1) == 1; }$/;"	f	class:GClause
isNegFormula	sat.h	/^      inline const bool isNegFormula(const size_t& v) const { return (v & 1ul); }$/;"	f	class:SatSolverV
l_False	GlobalV.h	/^const lbool l_False = toLbool(-1);$/;"	v
l_True	GlobalV.h	/^const lbool l_True  = toLbool( 1);$/;"	v
l_Undef	GlobalV.h	/^const lbool l_Undef = toLbool( 0);$/;"	v
last	GlobalV.h	/^    T&       last  (void)              { return data[sz-1]; }$/;"	f	class:vec
last	GlobalV.h	/^    const T& last  (void) const        { return data[sz-1]; }$/;"	f	class:vec
last	ProofV.h	/^    ClauseId last      () { assert(id_counter != ClauseId_NULL); return id_counter - 1; }$/;"	f	class:Proof
lastToFirst_lt	SolverV.cpp	/^    lastToFirst_lt(const vec<int>& t) : trail_pos(t) {}$/;"	f	class:lastToFirst_lt
lastToFirst_lt	SolverV.cpp	/^class lastToFirst_lt {  \/\/ Helper class to 'analyze' -- order literals from last to first occurance in 'trail[]'.$/;"	c	file:
lbool	GlobalV.h	/^    explicit lbool(int v) : value(v) { }$/;"	f	class:lbool
lbool	GlobalV.h	/^    lbool()       : value(0) { }$/;"	f	class:lbool
lbool	GlobalV.h	/^    lbool(bool x) : value((int)x*2-1) { }$/;"	f	class:lbool
lbool	GlobalV.h	/^class lbool {$/;"	c
learnt	SolverTypesV.h	/^    bool      learnt      ()      const { return size_learnt & 1; }$/;"	f	class:Clause
learnts	SolverV.h	/^    vec<Clause*>        learnts;          \/\/ List of learnt clauses.$/;"	m	class:SolverV
learnts_literals	SolverV.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
left	HeapV.h	/^static inline int left  (int i) { return i+i; }$/;"	f
level	SolverV.h	/^    vec<int>            level;            \/\/ 'level[var]' is the decision level at which assignment was made.$/;"	m	class:SolverV
lit	SolverTypesV.h	/^    Lit         lit      () const { return toLit(((intp)data) >> 1); }$/;"	f	class:GClause
locked	SolverV.h	/^    bool     locked          (const Clause* c) const { return reason[var((*c)[0])] == c; }$/;"	f	class:SolverV
lseek64	FileV.h	13;"	d
max	GlobalV.h	/^template<class T> static inline T max(T x, T y) { return (x > y) ? x : y; }$/;"	f
max_literals	SolverV.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
memReadStat	GlobalV.h	/^static inline int memReadStat(int field)$/;"	f
memUsed	GlobalV.h	/^static inline int64 memUsed() { return (int64)memReadStat(0) * (int64)getpagesize(); }$/;"	f
memUsed	GlobalV.h	/^static inline int64 memUsed() {$/;"	f
min	GlobalV.h	/^template<class T> static inline T min(T x, T y) { return (x < y) ? x : y; }$/;"	f
mkLit	SolverTypesV.h	/^inline  Lit  mkLit     (Var var, bool sign) { Lit p; p.x = var + var + (int)sign; return p; }$/;"	f
mode	FileV.h	/^    FileMode    mode;       \/\/ Reading or writing.$/;"	m	class:File
model	SolverV.h	/^    vec<lbool>  model;              \/\/ If problem is satisfiable, this vector contains the model (if any).$/;"	m	class:SolverV
moveTo	GlobalV.h	/^    void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }$/;"	f	class:vec
mySolve	SolverV.cpp	/^bool SolverV::mySolve(const vec<Lit>& assumps, int conflictThreshold, bool& result)$/;"	f	class:SolverV
nAssigns	SolverV.h	/^    int     nAssigns() { return trail.size(); }$/;"	f	class:SolverV
nClauses	SolverV.h	/^    int     nClauses() { return clauses.size(); }$/;"	f	class:SolverV
nLearnts	SolverV.h	/^    int     nLearnts() { return learnts.size(); }$/;"	f	class:SolverV
nRootCla	SolverV.h	/^    int     nRootCla() { return root_cla_count; } \/\/ MODIFICATION FOR SoCV$/;"	f	class:SolverV
nVars	SolverV.h	/^    int     nVars     ()                    { return assigns.size(); }$/;"	f	class:SolverV
nVars	sat.h	/^      int nVars() const { return _solver -> nVars(); }$/;"	f	class:SatSolverV
neg	SolverTypesV.h	/^	inline void neg() { x ^= 0x1; }$/;"	f	class:Lit
newClause	SolverV.cpp	/^void SolverV::newClause(const vec<Lit>& ps_, bool learnt, ClauseId id )$/;"	f	class:SolverV
newVar	SolverV.cpp	/^Var SolverV::newVar() {$/;"	f	class:SolverV
newVar	VarOrderV.h	/^void VarOrder::newVar(void)$/;"	f	class:VarOrder
newVar	sat.cpp	/^Var SatSolverV::newVar() {$/;"	f	class:SatSolverV
null	FileV.h	/^    bool null(void) {               \/\/ TRUE if no file is opened.$/;"	f	class:File
null	reader.h	/^	bool null()					{ return fd == -1; }$/;"	f	class:Reader
ok	HeapV.h	/^    bool ok(int n) { return n >= 0 && n < (int)indices.size(); }$/;"	f	class:Heap
ok	SolverV.h	/^    bool                ok;               \/\/ If FALSE, the constraints are already unsatisfiable. No part of the solver state may be used!$/;"	m	class:SolverV
okay	SolverV.h	/^    bool    okay() { return ok; }       \/\/ FALSE means solver is in an conflicting state (must never be used again!)$/;"	f	class:SolverV
open	FileV.cpp	/^void File::open(cchar* name, cchar* mode_)$/;"	f	class:File
open	FileV.cpp	/^void File::open(int file_descr, FileMode m, bool own)$/;"	f	class:File
open	ProofV.cpp	/^    char* open(File& fp)$/;"	f	class:TempFiles
open	reader.cpp	/^void Reader::open( const char* file_name ){$/;"	f	class:Reader
open	reader.cpp	/^void Reader::open(int filedesc)$/;"	f	class:Reader
open64	FileV.h	14;"	d
operator !=	GlobalV.h	/^    bool  operator != (const lbool& other) const { return value != other.value; }$/;"	f	class:lbool
operator !=	GlobalV.h	/^template <class T> static inline bool operator != (const T& x, const T& y) { return !(x == y); }$/;"	f
operator !=	SolverTypesV.h	/^    bool        operator != (GClause c) const { return data != c.data; }$/;"	f	class:GClause
operator ()	SolverV.cpp	/^    bool operator () (Lit p, Lit q) { return trail_pos[var(p)] > trail_pos[var(q)]; }$/;"	f	class:lastToFirst_lt
operator ()	SolverV.cpp	/^struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };$/;"	f	struct:reduceDB_lt
operator ()	SortV.h	/^    bool operator () (T x, T y) { return x < y; }$/;"	f	struct:LessThan_default
operator ()	VarOrderV.h	/^    bool operator () (Var x, Var y) { return activity[x] > activity[y]; }$/;"	f	struct:VarOrder_lt
operator <	SolverTypesV.h	/^inline bool operator <  (Lit p, Lit q) { return index(p)  < index(q); }  \/\/ '<' guarantees that p, ~p are adjacent in the ordering.$/;"	f
operator <=	GlobalV.h	/^template <class T> static inline bool operator <= (const T& x, const T& y) { return !(y < x);  }$/;"	f
operator =	GlobalV.h	/^vec<T>& vec<T>::operator = (const vec<T>& other){$/;"	f	class:vec
operator =	SolverTypesV.h	/^	inline void operator = (int n) { x = n; }$/;"	f	class:Lit
operator ==	GlobalV.h	/^    bool  operator == (const lbool& other) const { return value == other.value; }$/;"	f	class:lbool
operator ==	SolverTypesV.h	/^    bool        operator == (GClause c) const { return data == c.data; }$/;"	f	class:GClause
operator ==	SolverTypesV.h	/^inline bool operator == (Lit p, Lit q) { return index(p) == index(q); }$/;"	f
operator >	GlobalV.h	/^template <class T> static inline bool operator >  (const T& x, const T& y) { return y < x;     }$/;"	f
operator >=	GlobalV.h	/^template <class T> static inline bool operator >= (const T& x, const T& y) { return !(x < y);  }$/;"	f
operator T*	GlobalV.h	/^    operator T*       (void)           { return data; }     \/\/ (unsafe but convenient)$/;"	f	class:vec
operator []	GlobalV.h	/^    T&       operator [] (int index)        { return data[index]; }$/;"	f	class:vec
operator []	GlobalV.h	/^    const T& operator [] (int index) const  { return data[index]; }$/;"	f	class:vec
operator []	SolverTypesV.h	/^    Lit       operator [] (int i) const { return data[i]; }$/;"	f	class:Clause
operator []	SolverTypesV.h	/^    Lit&      operator [] (int i)       { return data[i]; }$/;"	f	class:Clause
operator const T*	GlobalV.h	/^    operator const T* (void) const     { return data; }$/;"	f	class:vec
operator ~	GlobalV.h	/^    lbool operator ~  (void)               const { return lbool(-value); }$/;"	f	class:lbool
operator ~	SolverTypesV.h	/^inline Lit operator ~ (Lit p) { Lit q; q.x = p.x ^ 1; return q; }$/;"	f
order	SolverV.h	/^    VarOrder            order;            \/\/ Keeps track of the decision variable order.$/;"	m	class:SolverV
overall_pos	reader.h	/^	unsigned int	overall_pos;$/;"	m	class:Reader
own_fd	FileV.h	/^    bool        own_fd;     \/\/ Do we own the file descriptor? If so, will close file in destructor.$/;"	m	class:File
parent	HeapV.h	/^static inline int parent(int i) { return i >> 1; }$/;"	f
percolateDown	HeapV.h	/^    inline void percolateDown(int i)$/;"	f	class:Heap
percolateUp	HeapV.h	/^    inline void percolateUp(int i)$/;"	f	class:Heap
pop	GlobalV.h	/^    void     pop    (void)             { sz--, data[sz].~T(); }$/;"	f	class:vec
pos	FileV.h	/^    int         pos;        \/\/ Current position in buffer$/;"	m	class:File
pos	reader.h	/^	unsigned int	pos;$/;"	m	class:Reader
progressEstimate	SolverV.cpp	/^double SolverV::progressEstimate()$/;"	f	class:SolverV
progress_estimate	SolverV.h	/^    double      progress_estimate;  \/\/ Set by 'search()'.$/;"	m	class:SolverV
proof	SolverV.h	/^    Proof*          proof;              \/\/ Set this directly after constructing 'Solver' to enable proof logging. Initialized to NULL.$/;"	m	class:SolverV
proof_logged	SolverV.h	/^    bool    proof_logged() { return false; }$/;"	f	class:SolverV
propagate	SolverV.cpp	/^Clause* SolverV::propagate()$/;"	f	class:SolverV
propagate_tmpbin	SolverV.h	/^    Clause*             propagate_tmpbin;$/;"	m	class:SolverV
propagations	SolverV.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
push	GlobalV.h	/^    void     push  (const T& elem)     { if (sz == cap) grow(sz+1); new (&data[sz]) T(elem); sz++; }$/;"	f	class:vec
push	GlobalV.h	/^    void     push  (void)              { if (sz == cap) grow(sz+1); new (&data[sz]) T()    ; sz++; }$/;"	f	class:vec
putChar	FileV.h	/^    int putChar(int chr) {$/;"	f	class:File
putCharQ	FileV.h	/^    int putCharQ(int chr) {         \/\/ Quick version with minimal overhead -- don't call this in the wrong mode!$/;"	f	class:File
putInt	FileV.h	/^static inline void   putInt  (File& out, int64 val) { putUInt(out, encode64(val)); }$/;"	f
putUInt	FileV.cpp	/^void putUInt(File& out, uint64 val)$/;"	f
qhead	SolverV.h	/^    int                 qhead;            \/\/ Head of queue (as index into the trail -- no more explicit propagation queue in MiniSat).$/;"	m	class:SolverV
random_seed	VarOrderV.h	/^    double              random_seed; \/\/ For the internal random number generator$/;"	m	class:VarOrder
random_var_freq	SolverV.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
reason	SolverV.h	/^    vec<Clause*>        reason;           \/\/ 'reason[var]' is the clause that implied the variables current value, or 'NULL' if none.$/;"	m	class:SolverV
reduceDB	SolverV.cpp	/^void SolverV::reduceDB()$/;"	f	class:SolverV
reduceDB_lt	SolverV.cpp	/^struct reduceDB_lt { bool operator () (Clause* x, Clause* y) { return x->size() > 2 && (y->size() == 2 || x->activity() < y->activity()); } };$/;"	s	file:
release	GlobalV.h	/^    T*       release  (void)           { T* ret = data; data = NULL; sz = 0; cap = 0; return ret; }$/;"	f	class:vec
releaseDescriptor	FileV.h	/^    int releaseDescriptor(void) {   \/\/ Don't run UNIX function 'close()' on descriptor in 'File's 'close()'.$/;"	f	class:File
remove	SolverV.cpp	/^void SolverV::remove(Clause* c, bool just_dealloc)$/;"	f	class:SolverV
removeWatch	SolverV.cpp	/^void removeWatch(vec<Clause*>& ws, Clause* elem)$/;"	f
reportf	SolverV.h	28;"	d
reserveFormula	sat.h	/^      inline const size_t reserveFormula() { return getPosVar(newVar()); }$/;"	f	class:SatSolverV
reset	sat.cpp	/^void SatSolverV::reset()$/;"	f	class:SatSolverV
resolve	ProofV.cpp	/^void Proof::resolve(ClauseId next, Var x)$/;"	f	class:Proof
right	HeapV.h	/^static inline int right (int i) { return i+i + 1; }$/;"	f
root	ProofV.h	/^    virtual void root   (const vec<Lit>& c) {}$/;"	f	struct:ProofTraverser
root_cla_count	SolverV.h	/^   int      root_cla_count;$/;"	m	class:SolverV
root_level	SolverV.h	/^    int                 root_level;       \/\/ Level of first proper decision.$/;"	m	class:SolverV
save	ProofV.cpp	/^bool Proof::save(cchar* filename)$/;"	f	class:Proof
search	SolverV.cpp	/^lbool SolverV::search(int nof_conflicts, int nof_learnts, const SearchParams& params)$/;"	f	class:SolverV
seek	FileV.cpp	/^void File::seek(int64 file_pos, int whence)$/;"	f	class:File
seek	reader.cpp	/^void Reader::seek( const unsigned int to ){$/;"	f	class:Reader
select	VarOrderV.h	/^Var VarOrder::select(double random_var_freq)$/;"	f	class:VarOrder
selectionSort	SortV.h	/^template <class T> static inline void selectionSort(T* array, int size) {$/;"	f
selectionSort	SortV.h	/^void selectionSort(T* array, int size, LessThan lt)$/;"	f
setBounds	HeapV.h	/^    void setBounds (int size) { assert(size >= 0); indices.growTo(size,0); }$/;"	f	class:Heap
setMode	FileV.h	/^    void setMode(FileMode m) {$/;"	f	class:File
shrink	GlobalV.h	/^    void     shrink (int nelems)       { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }$/;"	f	class:vec
sign	SolverTypesV.h	/^inline bool sign  (Lit p) { return p.x & 1; }$/;"	f
simpDB_assigns	SolverV.h	/^    int                 simpDB_assigns;   \/\/ Number of top-level assignments since last execution of 'simplifyDB()'.$/;"	m	class:SolverV
simpDB_props	SolverV.h	/^    int64               simpDB_props;     \/\/ Remaining number of propagations that must be made before next execution of 'simplifyDB()'.$/;"	m	class:SolverV
simplify	SolverV.cpp	/^bool SolverV::simplify(Clause* c) const$/;"	f	class:SolverV
simplify	sat.cpp	/^const bool SatSolverV::simplify() { return _solver->simplifyDB(); }$/;"	f	class:SatSolverV
simplifyDB	SolverV.cpp	/^bool SolverV::simplifyDB()$/;"	f	class:SolverV
size	FileV.h	/^    int         size;       \/\/ Size of buffer (at end of file, less than 'File_BufSize').$/;"	m	class:File
size	GlobalV.h	/^    int      size   (void) const       { return sz; }$/;"	f	class:vec
size	SolverTypesV.h	/^    int       size        ()      const { return size_learnt >> 1; }$/;"	f	class:Clause
size	reader.h	/^	unsigned int 	size;$/;"	m	class:Reader
size_learnt	SolverTypesV.h	/^    uint    size_learnt;$/;"	m	class:Clause
solve	SolverV.cpp	/^bool SolverV::solve(const vec<Lit>& assumps, bool zeroFirst)$/;"	f	class:SolverV
solve	SolverV.h	/^    bool    solve(bool zeroFirst = true) { vec<Lit> tmp; return solve(tmp, zeroFirst); }$/;"	f	class:SolverV
solve	sat.cpp	/^const bool SatSolverV::solve(bool zeroFirst)$/;"	f	class:SatSolverV
solveLimited	SolverV.cpp	/^lbool SolverV::solveLimited(const vec<Lit>& assumps, int64_t nConflicts)$/;"	f	class:SolverV
solveLimited	SolverV.h	/^    lbool   solveLimited(int64_t nConflicts) { vec<Lit> tmp; return solveLimited(nConflicts); }$/;"	f	class:SolverV
sort	SortV.h	/^template <class T, class LessThan> void sort(T* array, int size, LessThan lt) {$/;"	f
sort	SortV.h	/^template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {$/;"	f
sort	SortV.h	/^template <class T> static inline void sort(T* array, int size) {$/;"	f
sort	SortV.h	/^template <class T> void sort(vec<T>& v) {$/;"	f
sort	SortV.h	/^void sort(T* array, int size, LessThan lt, double& seed)$/;"	f
sortUnique	SortV.h	/^template <class T, class LessThan> void sortUnique(vec<T>& v, LessThan lt) {$/;"	f
sortUnique	SortV.h	/^template <class T> static inline void sortUnique(T* array, int& size) {$/;"	f
sortUnique	SortV.h	/^template <class T> void sortUnique(vec<T>& v) {$/;"	f
sortUnique	SortV.h	/^void sortUnique(T* array, int& size, LessThan lt)$/;"	f
start_proof_logging	SolverV.h	/^    bool    start_proof_logging() { return false; }$/;"	f	class:SolverV
starts	SolverV.h	/^    int64   starts, decisions, propagations, conflicts;$/;"	m	struct:SolverStats
stats	SolverV.h	/^    SolverStats     stats;$/;"	m	class:SolverV
sz	GlobalV.h	/^    int sz;$/;"	m	class:vec
tell	FileV.cpp	/^int64 File::tell(void)$/;"	f	class:File
temp_files	ProofV.cpp	/^static TempFiles temp_files;       \/\/ (should be singleton)$/;"	v	file:
toDimacs	SolverTypesV.h	/^inline int toDimacs(Lit p) { return sign(p) ? -var(p) - 1 : var(p) + 1; }$/;"	f
toInt	GlobalV.h	/^    int toInt(void) const { return value; }$/;"	f	class:lbool
toInt	GlobalV.h	/^inline int   toInt  (lbool l) { return l.toInt(); }$/;"	f
toLbool	GlobalV.h	/^inline lbool toLbool(int   v) { return lbool(v);  }$/;"	f
toLit	SolverTypesV.h	/^inline Lit  toLit (int i) { Lit p; p.x = i; return p; }  \/\/ Inverse of 'index()'.$/;"	f
tot_literals	SolverV.h	/^    int64   clauses_literals, learnts_literals, max_literals, tot_literals;$/;"	m	struct:SolverStats
trail	SolverV.h	/^    vec<Lit>            trail;            \/\/ Assignment stack; stores all assigments made in the order they were made.$/;"	m	class:SolverV
trail_lim	SolverV.h	/^    vec<int>            trail_lim;        \/\/ Separator indices for different decision levels in 'trail[]'.$/;"	m	class:SolverV
trail_pos	SolverV.cpp	/^    const vec<int>& trail_pos;$/;"	m	class:lastToFirst_lt	file:
trail_pos	SolverV.h	/^    vec<int>            trail_pos;        \/\/ 'trail_pos[var]' is the variable's position in 'trail[]'. This supersedes 'level[]' in some sense, and 'level[]' will probably be removed in future releases.$/;"	m	class:SolverV
trav	ProofV.h	/^    ProofTraverser* trav;$/;"	m	class:Proof
traverse	ProofV.cpp	/^void Proof::traverse(ProofTraverser& trav, ClauseId goal)$/;"	f	class:Proof
uchar	GlobalV.h	/^typedef unsigned char uchar;$/;"	t
uint64	GlobalV.h	/^typedef UINT64             uint64;$/;"	t
uint64	GlobalV.h	/^typedef unsigned long long uint64;$/;"	t
uintp	GlobalV.h	/^typedef UINT_PTR           uintp;$/;"	t
uintp	GlobalV.h	/^typedef unsigned __PTRDIFF_TYPE__ uintp;$/;"	t
undo	VarOrderV.h	/^void VarOrder::undo(Var x)$/;"	f	class:VarOrder
unit_id	SolverV.h	/^    vec<ClauseId>       unit_id;          \/\/ 'unit_id[var]' is the clause ID for the unit literal 'var' or '~var' (if set at toplevel).$/;"	m	class:SolverV
unsign	SolverTypesV.h	/^inline Lit  unsign(Lit p) { Lit q; q.x = p.x & ~1; return q; }$/;"	f
update	VarOrderV.h	/^void VarOrder::update(Var x)$/;"	f	class:VarOrder
value	GlobalV.h	/^    int     value;$/;"	m	class:lbool
value	SolverV.h	/^    lbool   value(Lit p) const { return sign(p) ? ~toLbool(assigns[var(p)]) : toLbool(assigns[var(p)]); }$/;"	f	class:SolverV
value	SolverV.h	/^    lbool   value(Var x) const { return toLbool(assigns[x]); }$/;"	f	class:SolverV
var	SolverTypesV.h	/^inline int  var   (Lit p) { return p.x >> 1; }$/;"	f
varBumpActivity	SolverV.h	/^    void     varBumpActivity(Lit p) {$/;"	f	class:SolverV
varDecayActivity	SolverV.h	/^    void     varDecayActivity  () { if (var_decay >= 0) var_inc *= var_decay; }$/;"	f	class:SolverV
varRescaleActivity	SolverV.cpp	/^void SolverV::varRescaleActivity()$/;"	f	class:SolverV
var_Undef	SolverTypesV.h	37;"	d
var_decay	SolverV.h	/^    double              var_decay;        \/\/ INVERSE decay factor for variable activity: stores 1\/decay. Use negative value for static variable order.$/;"	m	class:SolverV
var_decay	SolverV.h	/^    double  var_decay, clause_decay, random_var_freq;    \/\/ (reasonable values are: 0.95, 0.999, 0.02)    $/;"	m	struct:SearchParams
var_inc	SolverV.h	/^    double              var_inc;          \/\/ Amount to bump next variable with.$/;"	m	class:SolverV
vec	GlobalV.h	/^             vec        (vec<T>& other) { TEMPLATE_FAIL; }$/;"	f	class:vec
vec	GlobalV.h	/^    vec(T* array, int size)     : data(array), sz(size), cap(size) { }      \/\/ (takes ownership of array -- will be deallocated with 'xfree()')$/;"	f	class:vec
vec	GlobalV.h	/^    vec(int size)               : data(NULL) , sz(0)   , cap(0)    { growTo(size); }$/;"	f	class:vec
vec	GlobalV.h	/^    vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }$/;"	f	class:vec
vec	GlobalV.h	/^    vec(void)                   : data(NULL) , sz(0)   , cap(0)    { }$/;"	f	class:vec
vec	GlobalV.h	/^class vec {$/;"	c
verbosity	SolverV.h	/^    int             verbosity;          \/\/ Verbosity level. 0=silent, 1=some progress report, 2=everything$/;"	m	class:SolverV
version_info	SolverV.h	/^    inline const char* version_info() const { return "MINISAT Ver. 2.2"; }$/;"	f	class:SolverV
watches	SolverV.h	/^    vec<vec<Clause*> >  watches;          \/\/ 'watches[lit]' is a list of constraints watching 'lit' (will go there if literal becomes true).$/;"	m	class:SolverV
x	SolverTypesV.h	/^    int     x;$/;"	m	class:Lit
xfree	GlobalV.h	/^template<class T> static inline void xfree(T *ptr) {$/;"	f
xmalloc	GlobalV.h	/^template<class T> static inline T* xmalloc(size_t size) {$/;"	f
xrealloc	GlobalV.h	/^template<class T> static inline T* xrealloc(T* ptr, size_t size) {$/;"	f
~File	FileV.h	/^   ~File(void) {$/;"	f	class:File
~ProofTraverser	ProofV.h	/^    virtual ~ProofTraverser() {}$/;"	f	struct:ProofTraverser
~Reader	reader.cpp	/^Reader::~Reader(){$/;"	f	class:Reader
~SatSolverV	sat.cpp	/^SatSolverV::~SatSolverV() $/;"	f	class:SatSolverV
~SolverV	SolverV.h	/^   ~SolverV() {$/;"	f	class:SolverV
~TempFiles	ProofV.cpp	/^   ~TempFiles()$/;"	f	class:TempFiles
~vec	GlobalV.h	/^   ~vec(void)                                                      { clear(true); }$/;"	f	class:vec
